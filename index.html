
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peeper Online - 2~4ì¸ ë©€í‹°í”Œë ˆì´ì–´</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: 'Malgun Gothic', sans-serif; text-align: center; background: #1a1a2e; color: white; margin: 0; min-height: 100vh; }
        
        /* ë¡œë¹„ í™”ë©´ */
        #lobby { max-width: 500px; margin: 30px auto; padding: 30px; background: #16213e; border-radius: 20px; }
        #lobby h1 { color: #e94560; margin-bottom: 20px; }
        #lobby input, #lobby select { width: 100%; padding: 15px; font-size: 18px; border: none; border-radius: 10px; margin: 8px 0; text-align: center; }
        #lobby select { background: white; color: #333; }
        #lobby button { width: 100%; padding: 15px; font-size: 18px; border: none; border-radius: 10px; margin: 8px 0; cursor: pointer; font-weight: bold; }
        .btn-create { background: #e94560; color: white; }
        .btn-join { background: #0f3460; color: white; }
        .btn-create:hover { background: #ff6b6b; }
        .btn-join:hover { background: #1a508b; }
        #room-code-display { font-size: 2.5em; color: #e94560; font-weight: bold; letter-spacing: 8px; padding: 20px; background: #0f3460; border-radius: 10px; margin: 15px 0; }
        .waiting-msg { color: #ffc107; font-size: 1.1em; margin: 15px 0; }
        
        /* ì°¸ê°€ì ëª©ë¡ */
        #players-list { background: #0f3460; padding: 15px; border-radius: 10px; margin: 15px 0; text-align: left; }
        #players-list h3 { margin: 0 0 10px 0; color: #e94560; }
        .player-item { padding: 8px 12px; margin: 5px 0; background: #1a1a2e; border-radius: 5px; display: flex; justify-content: space-between; align-items: center; }
        .player-item.me { border: 2px solid #e94560; }
        .player-ready { color: #2ecc71; }
        .player-waiting { color: #f39c12; }
        
        /* ê²Œì„ í™”ë©´ */
        #game-container { max-width: 950px; margin: 15px auto; background: #16213e; padding: 20px; border-radius: 15px; display: none; }
        
        /* í—¤ë”© */
        h1 { color: #e94560; margin: 0 0 15px 0; font-size: 1.5em; }
        h2 { color: #eee; font-size: 1.1em; margin: 12px 0 8px 0; border-bottom: 2px solid #e94560; padding-bottom: 5px; text-align: left; }
        
        /* ì •ë³´ íŒ¨ë„ */
        .info-panel { display: flex; justify-content: space-around; background: #0f3460; padding: 12px; border-radius: 10px; margin-bottom: 12px; flex-wrap: wrap; gap: 8px; }
        .info-item { text-align: center; min-width: 70px; }
        .info-item strong { color: #e94560; font-size: 0.9em; }
        
        /* ìƒëŒ€ë°© ì˜ì—­ */
        #opponents-area { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 12px; }
        .opponent-card { background: #0f3460; padding: 12px 20px; border-radius: 10px; min-width: 150px; }
        .opponent-card.current-turn { border: 3px solid #ffc107; }
        .opponent-name { color: #e94560; font-weight: bold; font-size: 1.1em; }
        .opponent-count { color: #aaa; margin-top: 5px; }
        
        /* ë°”ë‹¥ ì˜ì—­ */
        .card-area { margin: 12px 0; padding: 15px; border: 3px solid #e94560; border-radius: 10px; background: #0f3460; min-height: 80px; }
        
        /* íŒ¨ ì˜ì—­ */
        .hand { display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; padding: 12px; background: #0f3460; border-radius: 10px; min-height: 90px; }
        
        /* ì¹´ë“œ */
        .card { 
            width: 48px; height: 68px; 
            border: 3px solid #eee; border-radius: 8px; 
            display: flex; align-items: center; justify-content: center; 
            cursor: pointer; background: #1a1a2e; color: #eee;
            font-weight: bold; font-size: 18px; user-select: none;
            transition: transform 0.1s, background 0.1s;
        }
        .card:focus { outline: 4px solid #ffc107; outline-offset: 2px; }
        .card[aria-selected="true"] { 
            background: #e94560; color: white; 
            transform: translateY(-10px); 
            border-color: #ff6b6b;
        }
        .card.joker { border-color: #ffc107; color: #ffc107; }
        .card.joker[aria-selected="true"] { background: #ff9800; color: #1a1a2e; }
        
        /* ë²„íŠ¼ */
        button { padding: 12px 20px; font-size: 15px; cursor: pointer; background: #e94560; color: white; border: none; border-radius: 8px; margin: 4px; font-weight: bold; }
        button:hover { background: #ff6b6b; }
        button:focus { outline: 3px solid #ffc107; outline-offset: 2px; }
        button:disabled { background: #444; cursor: not-allowed; color: #888; }
        .btn-pass { background: #0f3460; }
        .btn-clear { background: #6c5ce7; }
        
        /* ìƒíƒœ í‘œì‹œ */
        #turn-status { padding: 12px; border-radius: 8px; margin: 12px 0; font-size: 1.1em; font-weight: bold; }
        #turn-status.my-turn { background: #27ae60; }
        #turn-status.opponent-turn { background: #e74c3c; }
        #turn-status.waiting { background: #f39c12; }
        
        #selection-info { background: #6c5ce7; padding: 10px; border-radius: 8px; margin: 8px 0; font-size: 0.95em; }
        
        /* ë¡œê·¸ */
        #log { font-size: 12px; color: #ccc; height: 100px; overflow-y: auto; text-align: left; padding: 12px; background: #0f3460; border-radius: 8px; margin-top: 12px; }
        #log p { margin: 4px 0; padding: 4px; border-bottom: 1px solid #1a1a2e; }
        
        /* ìŠ¤í¬ë¦° ë¦¬ë” ì „ìš© */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
        
        /* í‚¤ë³´ë“œ ë„ì›€ë§ */
        .keyboard-help { font-size: 11px; color: #666; margin: 8px 0; padding: 8px; background: #0f3460; border-radius: 5px; }
        
        /* ì—°ê²° ìƒíƒœ */
        #connection-status { position: fixed; top: 10px; right: 10px; padding: 6px 12px; border-radius: 15px; font-size: 11px; }
        #connection-status.online { background: #27ae60; }
        #connection-status.offline { background: #e74c3c; }
        
        /* ê²Œì„ ê²°ê³¼ ëª¨ë‹¬ */
        #result-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 100; }
        #result-content { background: #16213e; padding: 40px; border-radius: 20px; text-align: center; }
        #result-content h2 { font-size: 2em; margin-bottom: 20px; }
        .win { color: #ffc107; }
        .lose { color: #e74c3c; }
        
        /* ìˆœìœ„ í‘œì‹œ */
        #rankings { text-align: left; margin: 20px 0; }
        .rank-item { padding: 10px; margin: 5px 0; background: #0f3460; border-radius: 8px; display: flex; align-items: center; gap: 15px; }
        .rank-number { font-size: 1.5em; font-weight: bold; width: 40px; }
        .rank-1 { color: #ffc107; }
        .rank-2 { color: #bdc3c7; }
        .rank-3 { color: #cd7f32; }
    </style>
</head>
<body>

<!-- ì—°ê²° ìƒíƒœ í‘œì‹œ -->
<div id="connection-status" class="offline" role="status" aria-live="polite">ì—°ê²° ì¤‘...</div>

<!-- ìŠ¤í¬ë¦° ë¦¬ë” ì•Œë¦¼ -->
<div id="live-announcer" class="sr-only" role="status" aria-live="assertive" aria-atomic="true"></div>

<!-- ==================== ë¡œë¹„ í™”ë©´ ==================== -->
<div id="lobby" role="main" aria-labelledby="lobby-title">
    <h1 id="lobby-title">ğŸ² í”¼í¼ ì˜¨ë¼ì¸</h1>
    <p style="color:#aaa; margin-bottom:20px;">2~4ì¸ ë©€í‹°í”Œë ˆì´ì–´</p>
    
    <div id="lobby-main">
        <label for="player-name" class="sr-only">ë‹‰ë„¤ì„</label>
        <input type="text" id="player-name" placeholder="ë‹‰ë„¤ì„ ì…ë ¥" maxlength="8" aria-required="true">
        
        <label for="player-count" class="sr-only">ì°¸ê°€ ì¸ì›</label>
        <select id="player-count">
            <option value="2">2ëª…</option>
            <option value="3">3ëª…</option>
            <option value="4">4ëª…</option>
        </select>
        
        <button class="btn-create" onclick="createRoom()">ìƒˆ ê²Œì„ ë§Œë“¤ê¸°</button>
        
        <p style="color:#666; margin: 15px 0;">â€” ë˜ëŠ” â€”</p>
        
        <label for="room-code-input" class="sr-only">ë°© ì½”ë“œ</label>
        <input type="text" id="room-code-input" placeholder="ë°© ì½”ë“œ ì…ë ¥ (6ìë¦¬)" maxlength="6" style="text-transform: uppercase;">
        <button class="btn-join" onclick="joinRoom()">ê²Œì„ ì°¸ê°€í•˜ê¸°</button>
    </div>
    
    <div id="lobby-waiting" style="display:none;">
        <h2 style="border:none; text-align:center;">ë°© ìƒì„± ì™„ë£Œ!</h2>
        <div id="room-code-display" aria-label="ë°© ì½”ë“œ">------</div>
        <p style="color:#aaa;">ì´ ì½”ë“œë¥¼ ì¹œêµ¬ì—ê²Œ ì•Œë ¤ì£¼ì„¸ìš”</p>
        
        <div id="players-list">
            <h3>ì°¸ê°€ì (<span id="current-player-count">1</span>/<span id="max-player-count">2</span>)</h3>
            <div id="players-container"></div>
        </div>
        
        <p class="waiting-msg" role="status" aria-live="polite" id="waiting-message">ğŸ‘€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
        <button onclick="cancelRoom()" style="background:#e74c3c;">ì·¨ì†Œí•˜ê¸°</button>
    </div>
</div>

<!-- ==================== ê²Œì„ í™”ë©´ ==================== -->
<div id="game-container" role="main" aria-labelledby="game-title">
    
    <h1 id="game-title">ğŸ² í”¼í¼ ì˜¨ë¼ì¸</h1>
    
    <!-- H2: ê²Œì„ í˜„í™© -->
    <h2 id="status-heading">ê²Œì„ í˜„í™©</h2>
    <div class="info-panel" role="region" aria-labelledby="status-heading">
        <div class="info-item">
            <strong>ë°© ì½”ë“œ</strong><br>
            <span id="game-room-code">------</span>
        </div>
        <div class="info-item">
            <strong>ì°¸ê°€ì</strong><br>
            <span id="game-player-count">2</span>ëª…
        </div>
        <div class="info-item">
            <strong>ë‚´ íŒ¨</strong><br>
            <span id="my-count">0</span>ì¥
        </div>
    </div>
    
    <!-- í„´ ìƒíƒœ -->
    <div id="turn-status" class="waiting" role="status" aria-live="assertive">
        ê²Œì„ ì¤€ë¹„ ì¤‘...
    </div>
    
    <!-- H2: ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ -->
    <h2 id="opponents-heading">ë‹¤ë¥¸ í”Œë ˆì´ì–´</h2>
    <div id="opponents-area" role="region" aria-labelledby="opponents-heading">
        <!-- ë™ì  ìƒì„± -->
    </div>
    
    <!-- H2: í˜„ì¬ ë°”ë‹¥ -->
    <h2 id="table-heading">í˜„ì¬ ë°”ë‹¥</h2>
    <div class="card-area" id="table-area" role="region" aria-labelledby="table-heading" aria-live="polite">
        <p id="table-description">ë°”ë‹¥ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.</p>
    </div>
    
    <!-- H2: ì„ íƒí•œ ì¹´ë“œ -->
    <h2 id="selection-heading">ì„ íƒí•œ ì¹´ë“œ</h2>
    <div id="selection-info" role="status" aria-labelledby="selection-heading" aria-live="polite">
        ì„ íƒëœ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.
    </div>
    
    <!-- H2: ë‚´ íŒ¨ -->
    <h2 id="hand-heading">ë‚´ íŒ¨ (<span id="hand-count">0</span>ì¥)</h2>
    <div class="hand" id="player-hand" role="listbox" aria-labelledby="hand-heading" aria-multiselectable="true">
    </div>
    
    <div class="keyboard-help" aria-hidden="true">
        [â†â†’: ì´ë™] [Space: ì„ íƒ] [P: ë‚´ê¸°] [X: íŒ¨ìŠ¤] [C: ì·¨ì†Œ] [S: ìƒí™©]
    </div>
    
    <!-- H2: ê²Œì„ ì¡°ì‘ -->
    <h2 id="controls-heading">ê²Œì„ ì¡°ì‘</h2>
    <div role="group" aria-labelledby="controls-heading">
        <button id="btn-play" onclick="playMove()">ì¹´ë“œ ë‚´ê¸° (P)</button>
        <button id="btn-pass" class="btn-pass" onclick="passTurn()">íŒ¨ìŠ¤ (X)</button>
        <button id="btn-clear" class="btn-clear" onclick="clearSelection()">ì„ íƒ ì·¨ì†Œ (C)</button>
    </div>
    
    <!-- H2: ê²Œì„ ë¡œê·¸ -->
    <h2 id="log-heading">ì§„í–‰ ê¸°ë¡</h2>
    <div id="log" role="log" aria-labelledby="log-heading" aria-live="polite"></div>
    
    <button onclick="leaveGame()" style="background:#e74c3c; margin-top:15px;">ê²Œì„ ë‚˜ê°€ê¸°</button>
</div>

<!-- ==================== ê²°ê³¼ ëª¨ë‹¬ ==================== -->
<div id="result-modal" role="dialog" aria-labelledby="result-title" aria-modal="true">
    <div id="result-content">
        <h2 id="result-title">ê²Œì„ ì¢…ë£Œ</h2>
        <div id="rankings"></div>
        <p id="result-message"></p>
        <button onclick="playAgain()">ë‹¤ì‹œ í•˜ê¸°</button>
        <button onclick="backToLobby()" style="background:#0f3460;">ë¡œë¹„ë¡œ</button>
    </div>
</div>

<!-- ==================== Firebase SDK ==================== -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getDatabase, ref, set, get, update, remove, onValue, onDisconnect, serverTimestamp 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

    // Firebase ì„¤ì •
    const firebaseConfig = {
        apiKey: "AIzaSyBuqOhMraxvfUW-KED-vY8MYRvvwB1NDCQA",
        authDomain: "peeper-game.firebaseapp.com",
        databaseURL: "https://peeper-game-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "peeper-game",
        storageBucket: "peeper-game.firebasestorage.app",
        messagingSenderId: "997321057268",
        appId: "1:997321057268:web:57c3c02a83d62578e5cfa1"
    };

    let app, db;
    let isFirebaseReady = false;
    
    try {
        app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        isFirebaseReady = true;
        updateConnectionStatus(true);
    } catch (error) {
        console.error("Firebase ì—°ê²° ì‹¤íŒ¨:", error);
        updateConnectionStatus(false);
    }

    // ==================== ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ====================
    let currentRoom = null;
    let myPlayerId = null;
    let myName = "";
    let maxPlayers = 2;
    let players = {};  // { player1: {name, hand, connected, finished, rank}, ... }
    let myHand = [];
    let lastMove = null;
    let currentTurn = null;
    let selectedIndices = [];
    let currentFocusIndex = 0;
    let roomListener = null;
    let finishedPlayers = [];  // ì™„ì£¼ ìˆœì„œ

    // ì „ì—­ í•¨ìˆ˜ ë…¸ì¶œ
    window.createRoom = createRoom;
    window.joinRoom = joinRoom;
    window.cancelRoom = cancelRoom;
    window.playMove = playMove;
    window.passTurn = passTurn;
    window.clearSelection = clearSelection;
    window.leaveGame = leaveGame;
    window.playAgain = playAgain;
    window.backToLobby = backToLobby;

    // ==================== ìœ í‹¸ë¦¬í‹° ====================
    function updateConnectionStatus(online) {
        const status = document.getElementById('connection-status');
        status.className = online ? 'online' : 'offline';
        status.textContent = online ? 'ì˜¨ë¼ì¸' : 'ì˜¤í”„ë¼ì¸';
    }

    function announce(message) {
        const announcer = document.getElementById('live-announcer');
        announcer.textContent = '';
        setTimeout(() => { announcer.textContent = message; }, 100);
    }

    function generateRoomCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));
        return code;
    }

    function createShuffledDeck() {
        const deck = [];
        for (let i = 1; i <= 16; i++) {
            for (let j = 0; j < 4; j++) deck.push(i);
        }
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    }

    function distributeCards(playerCount) {
        const deck = createShuffledDeck();
        const cardsPerPlayer = Math.floor(64 / playerCount);
        const hands = {};
        
        for (let i = 1; i <= playerCount; i++) {
            const start = (i - 1) * cardsPerPlayer;
            const end = i * cardsPerPlayer;
            hands[`player${i}`] = deck.slice(start, end).sort((a, b) => a - b);
        }
        
        return hands;
    }

    // ==================== ë°© ìƒì„± ====================
    async function createRoom() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }

        myName = document.getElementById('player-name').value.trim() || 'ë°©ì¥';
        maxPlayers = parseInt(document.getElementById('player-count').value);
        const roomCode = generateRoomCode();
        myPlayerId = 'player1';
        currentRoom = roomCode;

        try {
            await set(ref(db, `rooms/${roomCode}`), {
                code: roomCode,
                status: 'waiting',
                maxPlayers: maxPlayers,
                createdAt: serverTimestamp(),
                players: {
                    player1: {
                        name: myName,
                        connected: true,
                        finished: false,
                        rank: 0
                    }
                },
                gameState: null
            });

            onDisconnect(ref(db, `rooms/${roomCode}/players/player1/connected`)).set(false);

            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('max-player-count').textContent = maxPlayers;
            
            announce(`ë°©ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ë°© ì½”ë“œ ${roomCode.split('').join(' ')}. ${maxPlayers}ì¸ ê²Œì„.`);

            watchRoom(roomCode);

        } catch (error) {
            console.error("ë°© ìƒì„± ì‹¤íŒ¨:", error);
            alert("ë°© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }

    // ==================== ë°© ì°¸ê°€ ====================
    async function joinRoom() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }

        const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
        if (!roomCode || roomCode.length !== 6) {
            alert("6ìë¦¬ ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        myName = document.getElementById('player-name').value.trim() || 'í”Œë ˆì´ì–´';
        currentRoom = roomCode;

        try {
            const snapshot = await get(ref(db, `rooms/${roomCode}`));

            if (!snapshot.exists()) {
                alert("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°©ì…ë‹ˆë‹¤.");
                return;
            }

            const roomData = snapshot.val();
            
            if (roomData.status !== 'waiting') {
                alert("ì´ë¯¸ ê²Œì„ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.");
                return;
            }

            // ë¹ˆ ìŠ¬ë¡¯ ì°¾ê¸°
            const existingPlayers = Object.keys(roomData.players || {});
            if (existingPlayers.length >= roomData.maxPlayers) {
                alert("ë°©ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤.");
                return;
            }

            // ë‹¤ìŒ í”Œë ˆì´ì–´ ID í• ë‹¹
            let nextPlayerNum = 1;
            while (roomData.players?.[`player${nextPlayerNum}`]) {
                nextPlayerNum++;
            }
            myPlayerId = `player${nextPlayerNum}`;
            maxPlayers = roomData.maxPlayers;

            // ì°¸ê°€
            await update(ref(db, `rooms/${roomCode}/players`), {
                [myPlayerId]: {
                    name: myName,
                    connected: true,
                    finished: false,
                    rank: 0
                }
            });

            onDisconnect(ref(db, `rooms/${roomCode}/players/${myPlayerId}/connected`)).set(false);

            // ì¸ì›ì´ ë‹¤ ì°¼ìœ¼ë©´ ê²Œì„ ì‹œì‘
            const updatedSnapshot = await get(ref(db, `rooms/${roomCode}/players`));
            const currentPlayerCount = Object.keys(updatedSnapshot.val() || {}).length;

            if (currentPlayerCount >= maxPlayers) {
                // ê²Œì„ ì‹œì‘ - ì¹´ë“œ ë¶„ë°°
                const hands = distributeCards(maxPlayers);
                await update(ref(db, `rooms/${roomCode}`), {
                    status: 'playing',
                    gameState: {
                        hands: hands,
                        currentTurn: 'player1',
                        lastMove: null,
                        lastMoveBy: null,
                        passedBy: null,
                        finishedOrder: []
                    }
                });
            }

            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('max-player-count').textContent = maxPlayers;

            announce("ë°©ì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤.");
            watchRoom(roomCode);

        } catch (error) {
            console.error("ë°© ì°¸ê°€ ì‹¤íŒ¨:", error);
            alert("ë°© ì°¸ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }

    // ==================== ë°© ê°ì‹œ ====================
    function watchRoom(roomCode) {
        roomListener = onValue(ref(db, `rooms/${roomCode}`), (snapshot) => {
            if (!snapshot.exists()) {
                alert("ë°©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
                backToLobby();
                return;
            }
            handleRoomUpdate(snapshot.val());
        });
    }

    function handleRoomUpdate(data) {
        players = data.players || {};
        maxPlayers = data.maxPlayers;
        
        // ëŒ€ê¸° í™”ë©´ ì—…ë°ì´íŠ¸
        if (data.status === 'waiting') {
            updateWaitingScreen(data);
        }
        
        // ê²Œì„ ì§„í–‰ ì¤‘
        if (data.status === 'playing' && data.gameState) {
            showGameScreen();
            updateGameFromServer(data);
        }
        
        // ê²Œì„ ì¢…ë£Œ
        if (data.status === 'finished') {
            showResult(data);
        }
    }

    function updateWaitingScreen(data) {
        const container = document.getElementById('players-container');
        const playerList = Object.entries(data.players || {});
        
        container.innerHTML = playerList.map(([id, p]) => `
            <div class="player-item ${id === myPlayerId ? 'me' : ''}">
                <span>${p.name} ${id === myPlayerId ? '(ë‚˜)' : ''}</span>
                <span class="${p.connected ? 'player-ready' : 'player-waiting'}">
                    ${p.connected ? 'âœ“ ì¤€ë¹„' : 'ì—°ê²° ëŠê¹€'}
                </span>
            </div>
        `).join('');
        
        document.getElementById('current-player-count').textContent = playerList.length;
        
        const remaining = data.maxPlayers - playerList.length;
        document.getElementById('waiting-message').textContent = 
            remaining > 0 ? `ğŸ‘€ ${remaining}ëª… ë” í•„ìš”í•©ë‹ˆë‹¤...` : 'ğŸ® ê²Œì„ ì‹œì‘!';
    }

    // ==================== ê²Œì„ í™”ë©´ ====================
    function showGameScreen() {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        document.getElementById('game-room-code').textContent = currentRoom;
        document.getElementById('game-player-count').textContent = maxPlayers;
    }

    function updateGameFromServer(data) {
        const gs = data.gameState;
        
        // ë‚´ íŒ¨
        myHand = gs.hands?.[myPlayerId] || [];
        
        // í„´ ì •ë³´
        const wasMyTurn = currentTurn === myPlayerId;
        currentTurn = gs.currentTurn;
        const isMyTurn = currentTurn === myPlayerId;
        
        // ë°”ë‹¥ íŒ¨
        const prevLastMove = lastMove;
        lastMove = gs.lastMove;
        
        // ì™„ì£¼ì ëª©ë¡
        finishedPlayers = gs.finishedOrder || [];
        
        // ìƒëŒ€ë°© í–‰ë™ ì•Œë¦¼
        if (gs.lastMoveBy && gs.lastMoveBy !== myPlayerId && gs.lastMove) {
            if (!prevLastMove || prevLastMove.val !== gs.lastMove.val || prevLastMove.type !== gs.lastMove.type) {
                const playerName = players[gs.lastMoveBy]?.name || gs.lastMoveBy;
                const typeName = getTypeName(gs.lastMove.type);
                announce(`${playerName}ì´ ${typeName} ${gs.lastMove.val}ì„ ëƒˆìŠµë‹ˆë‹¤.`);
                logMessage(`ğŸƒ ${playerName}: ${typeName} ${gs.lastMove.val}`);
            }
        }
        
        if (gs.passedBy && gs.passedBy !== myPlayerId) {
            const playerName = players[gs.passedBy]?.name || gs.passedBy;
            announce(`${playerName}ì´ íŒ¨ìŠ¤í–ˆìŠµë‹ˆë‹¤.`);
            logMessage(`â­ï¸ ${playerName} íŒ¨ìŠ¤`);
        }
        
        // í„´ ë³€ê²½ ì•Œë¦¼
        if (!wasMyTurn && isMyTurn) {
            announce("ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.");
        }
        
        // UI ì—…ë°ì´íŠ¸
        renderOpponents(data);
        renderHand();
        updateAllInfo();
        
        if (isMyTurn && myHand.length > 0) {
            setTimeout(() => {
                const firstCard = document.querySelector('.card');
                if (firstCard) firstCard.focus();
            }, 100);
        }
    }

    function renderOpponents(data) {
        const gs = data.gameState;
        const area = document.getElementById('opponents-area');
        
        const opponents = Object.entries(players)
            .filter(([id]) => id !== myPlayerId)
            .map(([id, p]) => {
                const handCount = gs.hands?.[id]?.length || 0;
                const isCurrentTurn = gs.currentTurn === id;
                const isFinished = p.finished || handCount === 0;
                
                return `
                    <div class="opponent-card ${isCurrentTurn ? 'current-turn' : ''}" 
                         aria-label="${p.name}, íŒ¨ ${handCount}ì¥${isCurrentTurn ? ', í˜„ì¬ í„´' : ''}${isFinished ? ', ì™„ì£¼' : ''}">
                        <div class="opponent-name">${p.name}${isFinished ? ' ğŸ†' : ''}</div>
                        <div class="opponent-count">
                            ${isFinished ? `${p.rank}ë“± ì™„ì£¼!` : `íŒ¨ ${handCount}ì¥`}
                            ${isCurrentTurn ? ' â† í„´' : ''}
                        </div>
                    </div>
                `;
            });
        
        area.innerHTML = opponents.join('');
    }

    function renderHand() {
        const handDiv = document.getElementById('player-hand');
        handDiv.innerHTML = '';
        
        myHand.forEach((num, idx) => {
            const card = document.createElement('div');
            card.className = 'card' + (num === 16 ? ' joker' : '');
            card.id = `card-${idx}`;
            card.setAttribute('role', 'option');
            card.setAttribute('aria-selected', selectedIndices.includes(idx) ? 'true' : 'false');
            card.setAttribute('tabindex', idx === currentFocusIndex ? '0' : '-1');
            
            const cardName = num === 16 ? 'ì¡°ì»¤' : num;
            card.setAttribute('aria-label', `${cardName}, ${idx + 1}ë²ˆì§¸`);
            card.textContent = num === 16 ? 'X' : num;
            
            card.addEventListener('click', () => {
                if (currentTurn === myPlayerId) toggleCard(idx);
            });
            card.addEventListener('keydown', (e) => handleCardKeydown(e, idx));
            
            handDiv.appendChild(card);
        });
        
        document.getElementById('hand-count').textContent = myHand.length;
    }

    // ==================== ì¹´ë“œ ì„ íƒ ====================
    function toggleCard(idx) {
        const card = document.getElementById(`card-${idx}`);
        if (!card) return;
        
        const num = myHand[idx];
        const cardName = num === 16 ? 'ì¡°ì»¤' : num;
        
        if (selectedIndices.includes(idx)) {
            selectedIndices = selectedIndices.filter(i => i !== idx);
            card.setAttribute('aria-selected', 'false');
            announce(`${cardName} ì„ íƒ í•´ì œ. ${selectedIndices.length}ì¥ ì„ íƒë¨.`);
        } else {
            selectedIndices.push(idx);
            card.setAttribute('aria-selected', 'true');
            announce(`${cardName} ì„ íƒ. ${selectedIndices.length}ì¥ ì„ íƒë¨.`);
        }
        
        updateSelectionInfo();
    }

    function handleCardKeydown(e, idx) {
        const cards = document.querySelectorAll('.card');
        const cardCount = cards.length;
        
        switch (e.key) {
            case 'ArrowRight':
            case 'ArrowDown':
                e.preventDefault();
                moveFocusTo((idx + 1) % cardCount);
                break;
            case 'ArrowLeft':
            case 'ArrowUp':
                e.preventDefault();
                moveFocusTo((idx - 1 + cardCount) % cardCount);
                break;
            case ' ':
            case 'Enter':
                e.preventDefault();
                if (currentTurn === myPlayerId) toggleCard(idx);
                break;
            case 'p': case 'P': e.preventDefault(); playMove(); break;
            case 'x': case 'X': e.preventDefault(); passTurn(); break;
            case 'c': case 'C': e.preventDefault(); clearSelection(); break;
            case 's': case 'S': e.preventDefault(); announceStatus(); break;
        }
    }

    function moveFocusTo(newIndex) {
        const cards = document.querySelectorAll('.card');
        if (cards.length === 0) return;
        
        cards.forEach(c => c.setAttribute('tabindex', '-1'));
        currentFocusIndex = newIndex;
        cards[newIndex].setAttribute('tabindex', '0');
        cards[newIndex].focus();
        
        const num = myHand[newIndex];
        const cardName = num === 16 ? 'ì¡°ì»¤' : num;
        const isSelected = selectedIndices.includes(newIndex);
        announce(`${cardName}${isSelected ? ', ì„ íƒë¨' : ''}`);
    }

    // ==================== ì •ë³´ ì—…ë°ì´íŠ¸ ====================
    function updateAllInfo() {
        const isMyTurn = currentTurn === myPlayerId;
        document.getElementById('my-count').textContent = myHand.length;
        
        const turnDiv = document.getElementById('turn-status');
        if (isMyTurn) {
            turnDiv.className = 'my-turn';
            turnDiv.textContent = 'ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤!';
        } else {
            const turnPlayerName = players[currentTurn]?.name || 'ìƒëŒ€ë°©';
            turnDiv.className = 'opponent-turn';
            turnDiv.textContent = `${turnPlayerName}ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤...`;
        }
        
        const tableDiv = document.getElementById('table-description');
        if (!lastMove) {
            tableDiv.textContent = 'ë°”ë‹¥ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤. ììœ ë¡­ê²Œ ì¹´ë“œë¥¼ ë‚´ì„¸ìš”.';
        } else {
            tableDiv.textContent = `${getTypeName(lastMove.type)}, ì‹œì‘ê°’ ${lastMove.val}, ${lastMove.cnt}ì¥`;
        }
        
        document.getElementById('btn-play').disabled = !isMyTurn;
        document.getElementById('btn-pass').disabled = !isMyTurn;
        
        updateSelectionInfo();
    }

    function updateSelectionInfo() {
        const infoDiv = document.getElementById('selection-info');
        
        if (selectedIndices.length === 0) {
            infoDiv.textContent = 'ì„ íƒëœ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.';
            return;
        }
        
        const selectedCards = selectedIndices.map(i => myHand[i]).sort((a, b) => a - b);
        const cardNames = selectedCards.map(n => n === 16 ? 'ì¡°ì»¤' : n).join(', ');
        const moveInfo = getMoveInfo(selectedCards);
        
        if (moveInfo) {
            infoDiv.textContent = `ì„ íƒ: ${cardNames} â†’ ${getTypeName(moveInfo.type)} (ì‹œì‘ê°’ ${moveInfo.val})`;
        } else {
            infoDiv.textContent = `ì„ íƒ: ${cardNames} â†’ ìœ íš¨í•˜ì§€ ì•Šì€ ì¡°í•©`;
        }
    }

    function announceStatus() {
        const isMyTurn = currentTurn === myPlayerId;
        let msg = `ë‚´ íŒ¨ ${myHand.length}ì¥. `;
        msg += lastMove ? `ë°”ë‹¥: ${getTypeName(lastMove.type)} ${lastMove.val}. ` : 'ë°”ë‹¥ ë¹„ì—ˆìŒ. ';
        msg += isMyTurn ? 'ë‚´ ì°¨ë¡€.' : `${players[currentTurn]?.name || 'ìƒëŒ€ë°©'} ì°¨ë¡€.`;
        announce(msg);
    }

    function clearSelection() {
        selectedIndices.forEach(idx => {
            const card = document.getElementById(`card-${idx}`);
            if (card) card.setAttribute('aria-selected', 'false');
        });
        selectedIndices = [];
        updateSelectionInfo();
        announce('ì„ íƒ ì·¨ì†Œë¨.');
    }

    // ==================== ì¹´ë“œ íŒì • ====================
    function getMoveInfo(cards) {
        if (cards.length === 0) return null;
        
        let sorted = [...cards].sort((a, b) => a - b);
        let count = sorted.length;
        
        if (sorted.every(c => c === sorted[0])) {
            if (count === 4) return { type: 'QUAD', val: sorted[0], cnt: 4 };
            if (count === 3) return { type: 'BOMB', val: sorted[0], cnt: 3 };
            if (count === 2) return { type: 'PAIR', val: sorted[0], cnt: 2 };
            if (count === 1) return { type: 'SINGLE', val: sorted[0], cnt: 1 };
        }
        
        let isStr = true;
        for (let i = 0; i < count - 1; i++) {
            if (sorted[i] + 1 !== sorted[i + 1]) isStr = false;
        }
        if (isStr && count >= 3) return { type: 'STRAIGHT', val: sorted[0], cnt: count };
        
        return null;
    }

    function canBeat(newMove) {
        if (!lastMove) return true;
        
        if (newMove.type === 'QUAD') {
            if (lastMove.type !== 'QUAD') return true;
            return newMove.val > lastMove.val;
        }
        
        if (newMove.type === 'BOMB') {
            if (lastMove.type === 'QUAD') return false;
            if (lastMove.type !== 'BOMB') return true;
            return newMove.val > lastMove.val;
        }
        
        if (newMove.type === lastMove.type && newMove.cnt === lastMove.cnt) {
            return newMove.val > lastMove.val;
        }
        
        return false;
    }

    function getTypeName(type) {
        const names = { 'SINGLE': 'ì‹±ê¸€', 'PAIR': 'í˜ì–´', 'STRAIGHT': 'ìŠ¤íŠ¸ë ˆì´íŠ¸', 'BOMB': 'íŠ¸ë¦¬í”Œ', 'QUAD': 'ì¿¼ë“œ' };
        return names[type] || type;
    }

    // ==================== ë‹¤ìŒ í„´ ê³„ì‚° ====================
    function getNextTurn(currentTurnId, skipFinished = true) {
        const playerIds = [];
        for (let i = 1; i <= maxPlayers; i++) {
            playerIds.push(`player${i}`);
        }
        
        let currentIdx = playerIds.indexOf(currentTurnId);
        let nextIdx = (currentIdx + 1) % playerIds.length;
        let attempts = 0;
        
        while (attempts < playerIds.length) {
            const nextId = playerIds[nextIdx];
            const player = players[nextId];
            
            // ì™„ì£¼í•˜ì§€ ì•Šì€ í”Œë ˆì´ì–´ ì°¾ê¸°
            if (!player?.finished && player?.connected) {
                return nextId;
            }
            
            nextIdx = (nextIdx + 1) % playerIds.length;
            attempts++;
        }
        
        return null;  // ëª¨ë‘ ì™„ì£¼
    }

    // ==================== ì¹´ë“œ ë‚´ê¸° ====================
    async function playMove() {
        if (currentTurn !== myPlayerId) {
            announce('ì§€ê¸ˆì€ ë‹¹ì‹ ì˜ ì°¨ë¡€ê°€ ì•„ë‹™ë‹ˆë‹¤.');
            return;
        }
        
        if (selectedIndices.length === 0) {
            announce('ì¹´ë“œë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
            return;
        }
        
        let cards = selectedIndices.map(idx => myHand[idx]);
        
        // ì¡°ì»¤ ì²˜ë¦¬
        if (cards.includes(16)) {
            let jokerCount = cards.filter(x => x === 16).length;
            for (let i = 0; i < jokerCount; i++) {
                let input = prompt(`${i + 1}ë²ˆì§¸ ì¡°ì»¤ë¥¼ ì–´ë–¤ ìˆ«ìë¡œ? (1~15)`, "1");
                let targetVal = parseInt(input);
                if (isNaN(targetVal) || targetVal < 1 || targetVal > 15) targetVal = 1;
                let targetIdx = cards.indexOf(16);
                cards[targetIdx] = targetVal;
            }
        }
        
        const move = getMoveInfo(cards);
        
        if (!move) {
            announce('ìœ íš¨í•˜ì§€ ì•Šì€ ì¡°í•©ì…ë‹ˆë‹¤.');
            return;
        }
        
        // ë¦¬í„´ ì²´í¬
        if (lastMove && lastMove.type === 'SINGLE' && move.type === 'SINGLE' && move.val === lastMove.val) {
            announce(`ë¦¬í„´! ë‹¤ì‹œ ë‚´ í„´!`);
            logMessage(`ğŸ”„ ë¦¬í„´! ${getTypeName(move.type)} ${move.val}`);
            await submitMove(move, true);
            return;
        }
        
        if (canBeat(move)) {
            announce(`${getTypeName(move.type)} ${move.val} ëƒˆìŠµë‹ˆë‹¤.`);
            logMessage(`âœ… ë‚˜: ${getTypeName(move.type)} ${move.val}`);
            await submitMove(move, false);
        } else {
            announce('ë°”ë‹¥ì„ ì´ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
    }

    async function submitMove(move, keepTurn) {
        const newHand = myHand.filter((_, i) => !selectedIndices.includes(i));
        selectedIndices = [];
        
        const updates = {
            [`gameState/hands/${myPlayerId}`]: newHand,
            'gameState/lastMove': move,
            'gameState/lastMoveBy': myPlayerId,
            'gameState/passedBy': null
        };
        
        // ì™„ì£¼ ì²´í¬
        if (newHand.length === 0) {
            const currentFinished = finishedPlayers.length;
            const myRank = currentFinished + 1;
            
            updates[`players/${myPlayerId}/finished`] = true;
            updates[`players/${myPlayerId}/rank`] = myRank;
            updates['gameState/finishedOrder'] = [...finishedPlayers, myPlayerId];
            
            // ë‚¨ì€ í”Œë ˆì´ì–´ ì²´í¬
            const remainingPlayers = Object.entries(players)
                .filter(([id, p]) => id !== myPlayerId && !p.finished)
                .length;
            
            if (remainingPlayers <= 1) {
                // ê²Œì„ ì¢…ë£Œ
                updates['status'] = 'finished';
            } else {
                // ë‹¤ìŒ í„´
                updates['gameState/currentTurn'] = getNextTurn(myPlayerId);
            }
        } else {
            // ë‹¤ìŒ í„´
            updates['gameState/currentTurn'] = keepTurn ? myPlayerId : getNextTurn(myPlayerId);
        }
        
        await update(ref(db, `rooms/${currentRoom}`), updates);
    }

    // ==================== íŒ¨ìŠ¤ ====================
    async function passTurn() {
        if (currentTurn !== myPlayerId) {
            announce('ì§€ê¸ˆì€ ë‹¹ì‹ ì˜ ì°¨ë¡€ê°€ ì•„ë‹™ë‹ˆë‹¤.');
            return;
        }
        
        announce('íŒ¨ìŠ¤í–ˆìŠµë‹ˆë‹¤.');
        logMessage('â­ï¸ íŒ¨ìŠ¤');
        
        const nextTurn = getNextTurn(myPlayerId);
        
        await update(ref(db, `rooms/${currentRoom}/gameState`), {
            currentTurn: nextTurn,
            lastMove: null,
            lastMoveBy: null,
            passedBy: myPlayerId
        });
        
        clearSelection();
    }

    // ==================== ê²°ê³¼ í‘œì‹œ ====================
    function showResult(data) {
        const modal = document.getElementById('result-modal');
        const title = document.getElementById('result-title');
        const rankings = document.getElementById('rankings');
        const msg = document.getElementById('result-message');
        
        // ìˆœìœ„ ì •ë ¬
        const sortedPlayers = Object.entries(data.players)
            .map(([id, p]) => ({ id, ...p }))
            .sort((a, b) => {
                if (a.rank && b.rank) return a.rank - b.rank;
                if (a.rank) return -1;
                if (b.rank) return 1;
                return 0;
            });
        
        // ìˆœìœ„ í‘œì‹œ
        rankings.innerHTML = sortedPlayers.map((p, idx) => {
            const rank = p.rank || (idx + 1);
            const rankClass = rank <= 3 ? `rank-${rank}` : '';
            const isMe = p.id === myPlayerId;
            
            return `
                <div class="rank-item" ${isMe ? 'style="border: 2px solid #e94560;"' : ''}>
                    <span class="rank-number ${rankClass}">${rank}ë“±</span>
                    <span>${p.name}${isMe ? ' (ë‚˜)' : ''}</span>
                </div>
            `;
        }).join('');
        
        const myRank = data.players[myPlayerId]?.rank || sortedPlayers.length;
        
        if (myRank === 1) {
            title.className = 'win';
            title.textContent = 'ğŸ‰ 1ë“±! ìŠ¹ë¦¬!';
            announce('ì¶•í•˜í•©ë‹ˆë‹¤! 1ë“±ìœ¼ë¡œ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!');
        } else {
            title.className = 'lose';
            title.textContent = `${myRank}ë“±`;
            announce(`${myRank}ë“±ì…ë‹ˆë‹¤.`);
        }
        
        msg.textContent = '';
        modal.style.display = 'flex';
    }

    // ==================== ê²Œì„ ê´€ë¦¬ ====================
    async function cancelRoom() {
        if (currentRoom) {
            try { await remove(ref(db, `rooms/${currentRoom}`)); } catch (e) {}
        }
        if (roomListener) roomListener();
        backToLobby();
    }

    async function leaveGame() {
        if (currentRoom) {
            try {
                await update(ref(db, `rooms/${currentRoom}/players/${myPlayerId}`), {
                    connected: false
                });
            } catch (e) {}
        }
        backToLobby();
    }

    function backToLobby() {
        if (roomListener) roomListener();
        currentRoom = null;
        myPlayerId = null;
        myHand = [];
        selectedIndices = [];
        lastMove = null;
        players = {};
        finishedPlayers = [];
        
        document.getElementById('result-modal').style.display = 'none';
        document.getElementById('game-container').style.display = 'none';
        document.getElementById('lobby').style.display = 'block';
        document.getElementById('lobby-main').style.display = 'block';
        document.getElementById('lobby-waiting').style.display = 'none';
        document.getElementById('log').innerHTML = '';
    }

    async function playAgain() {
        document.getElementById('result-modal').style.display = 'none';
        
        if (myPlayerId === 'player1') {
            const hands = distributeCards(maxPlayers);
            
            // í”Œë ˆì´ì–´ ìƒíƒœ ë¦¬ì…‹
            const playerUpdates = {};
            Object.keys(players).forEach(id => {
                playerUpdates[`players/${id}/finished`] = false;
                playerUpdates[`players/${id}/rank`] = 0;
            });
            
            await update(ref(db, `rooms/${currentRoom}`), {
                status: 'playing',
                ...playerUpdates,
                gameState: {
                    hands: hands,
                    currentTurn: 'player1',
                    lastMove: null,
                    lastMoveBy: null,
                    passedBy: null,
                    finishedOrder: []
                }
            });
        }
    }

    function logMessage(msg) {
        const logBox = document.getElementById('log');
        const p = document.createElement('p');
        p.textContent = msg;
        logBox.insertBefore(p, logBox.firstChild);
    }

    // ì „ì—­ í‚¤ë³´ë“œ
    document.addEventListener('keydown', (e) => {
        if (document.getElementById('lobby').style.display !== 'none') return;
        if (document.getElementById('result-modal').style.display === 'flex') return;
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
        
        switch (e.key) {
            case 'p': case 'P': playMove(); break;
            case 'x': case 'X': passTurn(); break;
            case 'c': case 'C': clearSelection(); break;
            case 's': case 'S': announceStatus(); break;
        }
    });
</script>
</body>
</html>
