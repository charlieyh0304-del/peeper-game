<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peeper Online - 2~4ì¸ ë©€í‹°í”Œë ˆì´ì–´</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: 'Malgun Gothic', sans-serif; text-align: center; background: #1a1a2e; color: white; margin: 0; min-height: 100vh; }
        
        /* ë¡œë¹„ í™”ë©´ */
        #lobby { max-width: 500px; margin: 30px auto; padding: 30px; background: #16213e; border-radius: 20px; }
        #lobby h1 { color: #e94560; margin-bottom: 20px; }
        #lobby input, #lobby select { width: 100%; padding: 15px; font-size: 18px; border: none; border-radius: 10px; margin: 8px 0; text-align: center; }
        #lobby select { background: white; color: #333; }
        #lobby button { width: 100%; padding: 15px; font-size: 18px; border: none; border-radius: 10px; margin: 8px 0; cursor: pointer; font-weight: bold; }
        .btn-create { background: #e94560; color: white; }
        .btn-join { background: #0f3460; color: white; }
        .btn-create:hover { background: #ff6b6b; }
        .btn-join:hover { background: #1a508b; }
        #room-code-display { font-size: 2.5em; color: #e94560; font-weight: bold; letter-spacing: 8px; padding: 20px; background: #0f3460; border-radius: 10px; margin: 15px 0; }
        .waiting-msg { color: #ffc107; font-size: 1.1em; margin: 15px 0; }
        
        /* íƒ­ ë©”ë‰´ */
        .tab-menu { display: flex; gap: 5px; margin: 20px 0 0 0; border-bottom: 2px solid #0f3460; }
        .tab-btn { 
            flex: 1; padding: 12px 8px; font-size: 14px; font-weight: bold;
            background: #0f3460; color: #aaa; border: none; border-radius: 10px 10px 0 0;
            cursor: pointer; transition: all 0.2s;
        }
        .tab-btn:hover { background: #1a508b; color: #fff; }
        .tab-btn:focus { outline: 3px solid #ffc107; outline-offset: 2px; }
        .tab-btn.active, .tab-btn[aria-selected="true"] { 
            background: #e94560; color: white; 
        }
        .tab-panel { 
            background: #0f3460; padding: 20px; border-radius: 0 0 10px 10px; 
            margin-bottom: 15px;
        }
        .panel-title { 
            color: #e94560; font-size: 1.1em; margin: 0 0 15px 0; 
            border: none; text-align: center; 
        }
        .btn-spectate { background: #9b59b6; color: white; }
        .btn-spectate:hover { background: #8e44ad; }
        
        /* ì°¸ê°€ì ëª©ë¡ */
        #players-list { background: #0f3460; padding: 15px; border-radius: 10px; margin: 15px 0; text-align: left; }
        #players-list h3 { margin: 0 0 10px 0; color: #e94560; }
        .player-item { padding: 8px 12px; margin: 5px 0; background: #1a1a2e; border-radius: 5px; display: flex; justify-content: space-between; align-items: center; }
        .player-item.me { border: 2px solid #e94560; }
        .player-item.ai-player { border: 2px solid #9b59b6; background: #2d1f3d; }
        .player-ready { color: #2ecc71; }
        .player-waiting { color: #f39c12; }
        
        /* ê²Œì„ í™”ë©´ */
        #game-container { max-width: 950px; margin: 15px auto; background: #16213e; padding: 20px; border-radius: 15px; display: none; }
        
        /* í—¤ë”© */
        h1 { color: #e94560; margin: 0 0 15px 0; font-size: 1.5em; }
        h2 { color: #eee; font-size: 1.1em; margin: 12px 0 8px 0; border-bottom: 2px solid #e94560; padding-bottom: 5px; text-align: left; }
        
        /* ì •ë³´ íŒ¨ë„ */
        .info-panel { display: flex; justify-content: space-around; background: #0f3460; padding: 12px; border-radius: 10px; margin-bottom: 12px; flex-wrap: wrap; gap: 8px; }
        .info-item { text-align: center; min-width: 70px; }
        .info-item strong { color: #e94560; font-size: 0.9em; }
        
        /* ìƒëŒ€ë°© ì˜ì—­ */
        #opponents-area { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 12px; }
        .opponent-card { background: #0f3460; padding: 12px 20px; border-radius: 10px; min-width: 150px; }
        .opponent-card.current-turn { border: 3px solid #ffc107; }
        .opponent-name { color: #e94560; font-weight: bold; font-size: 1.1em; }
        .opponent-count { color: #aaa; margin-top: 5px; }
        
        /* ë°”ë‹¥ ì˜ì—­ */
        .card-area { margin: 12px 0; padding: 15px; border: 3px solid #e94560; border-radius: 10px; background: #0f3460; min-height: 80px; }
        
        /* íŒ¨ ì˜ì—­ */
        .hand { display: flex; flex-wrap: wrap; justify-content: center; gap: 6px; padding: 12px; background: #0f3460; border-radius: 10px; min-height: 90px; }
        
        /* ì¹´ë“œ */
        .card { 
            width: 48px; height: 68px; 
            border: 3px solid #eee; border-radius: 8px; 
            display: flex; align-items: center; justify-content: center; 
            cursor: pointer; background: #1a1a2e; color: #eee;
            font-weight: bold; font-size: 18px; user-select: none;
            transition: transform 0.1s, background 0.1s;
            position: relative;
        }
        .card:focus { outline: 4px solid #ffc107; outline-offset: 2px; }
        .card[aria-pressed="true"] { 
            background: #e94560; color: white; 
            transform: translateY(-10px); 
            border-color: #ff6b6b;
            box-shadow: 0 8px 20px rgba(233, 69, 96, 0.5);
        }
        .card[aria-pressed="true"]::after {
            content: "âœ“";
            position: absolute;
            top: -12px;
            right: -12px;
            background: #27ae60;
            color: white;
            font-size: 14px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }
        .card.joker { border-color: #ffc107; color: #ffc107; }
        .card.joker[aria-pressed="true"] { background: #ff9800; color: #1a1a2e; }
        .card.red-one { border-color: #ff0000; color: #ff0000; background: #2a1a1a; }
        .card.red-one[aria-pressed="true"] { background: #ff0000; color: white; border-color: #ff6b6b; }
        
        /* ë²„íŠ¼ */
        button { padding: 12px 20px; font-size: 15px; cursor: pointer; background: #e94560; color: white; border: none; border-radius: 8px; margin: 4px; font-weight: bold; }
        button:hover { background: #ff6b6b; }
        button:focus { outline: 3px solid #ffc107; outline-offset: 2px; }
        button:disabled { background: #444; cursor: not-allowed; color: #888; }
        .btn-pass { background: #0f3460; }
        .btn-clear { background: #6c5ce7; }
        
        /* ìƒíƒœ í‘œì‹œ */
        #turn-status { padding: 12px; border-radius: 8px; margin: 12px 0; font-size: 1.1em; font-weight: bold; }
        #turn-status.my-turn { background: #27ae60; }
        #turn-status.opponent-turn { background: #e74c3c; }
        #turn-status.waiting { background: #f39c12; }
        
        #selection-info { background: #6c5ce7; padding: 10px; border-radius: 8px; margin: 8px 0; font-size: 0.95em; }
        
        /* ë¡œê·¸ */
        #log { font-size: 12px; color: #ccc; height: 100px; overflow-y: auto; text-align: left; padding: 12px; background: #0f3460; border-radius: 8px; margin-top: 12px; }
        #log p { margin: 4px 0; padding: 4px; border-bottom: 1px solid #1a1a2e; }
        
        /* ì±„íŒ… */
        #chat-container { background: #0f3460; border-radius: 8px; margin-top: 12px; overflow: hidden; }
        #chat-messages { 
            height: 120px; overflow-y: auto; padding: 12px; text-align: left; 
            font-size: 13px; color: #eee;
        }
        .chat-list { list-style: none; margin: 0; padding: 0; }
        .chat-list li { margin: 8px 0; padding: 8px 10px; background: #1a1a2e; border-radius: 8px; line-height: 1.4; }
        .chat-list li strong { color: #e94560; }
        #chat-input-area { display: flex; gap: 8px; padding: 10px; background: #1a1a2e; }
        #chat-input { 
            flex: 1; padding: 10px; font-size: 14px; border: none; border-radius: 8px; 
            background: #0f3460; color: white;
        }
        #chat-input:focus { outline: 2px solid #e94560; }
        #chat-send { padding: 10px 20px; background: #e94560; min-width: auto; }
        
        /* ìŠ¤í¬ë¦° ë¦¬ë” ì „ìš© */
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
        
        /* í‚¤ë³´ë“œ ë„ì›€ë§ */
        .keyboard-help { font-size: 11px; color: #666; margin: 8px 0; padding: 8px; background: #0f3460; border-radius: 5px; }
        
        /* ì—°ê²° ìƒíƒœ */
        #connection-status { position: fixed; top: 10px; right: 10px; padding: 6px 12px; border-radius: 15px; font-size: 11px; }
        #connection-status.online { background: #27ae60; }
        #connection-status.offline { background: #e74c3c; }
        
        /* ê²Œì„ ê²°ê³¼ ëª¨ë‹¬ */
        #result-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 100; }
        #result-content { background: #16213e; padding: 40px; border-radius: 20px; text-align: center; }
        #result-content h2 { font-size: 2em; margin-bottom: 20px; }
        .win { color: #ffc107; }
        .lose { color: #e74c3c; }
        
        /* ìˆœìœ„ í‘œì‹œ */
        #rankings { text-align: left; margin: 20px 0; }
        .rank-item { padding: 10px; margin: 5px 0; background: #0f3460; border-radius: 8px; display: flex; align-items: center; gap: 15px; }
        .rank-number { font-size: 1.5em; font-weight: bold; width: 40px; }
        .rank-1 { color: #ffc107; }
        .rank-2 { color: #bdc3c7; }
        .rank-3 { color: #cd7f32; }
        
        /* ==================== ëª¨ë°”ì¼ ìµœì í™” ==================== */
        @media (max-width: 600px) {
            /* ë¡œë¹„ */
            #lobby { margin: 10px; padding: 20px; border-radius: 15px; }
            #lobby h1 { font-size: 1.5em; }
            #lobby input, #lobby select, #lobby button { 
                padding: 14px; 
                font-size: 16px; 
                -webkit-appearance: none;
            }
            #room-code-display { font-size: 1.8em; letter-spacing: 5px; padding: 15px; }
            
            /* ê²Œì„ í™”ë©´ */
            #game-container { margin: 5px; padding: 12px; border-radius: 10px; }
            h1 { font-size: 1.3em; }
            h2 { font-size: 1em; margin: 10px 0 6px 0; }
            
            /* ì •ë³´ íŒ¨ë„ */
            .info-panel { padding: 10px; gap: 5px; }
            .info-item { min-width: 60px; font-size: 0.9em; }
            
            /* ìƒëŒ€ë°© ì¹´ë“œ */
            .opponent-card { padding: 10px 15px; min-width: 120px; }
            .opponent-name { font-size: 1em; }
            
            /* ì¹´ë“œ - ëª¨ë°”ì¼ì—ì„œ ë” í¬ê²Œ */
            .card { 
                width: 44px; height: 62px; 
                font-size: 16px;
                border-width: 2px;
            }
            .card[aria-pressed="true"] { transform: translateY(-8px); }
            .hand { gap: 4px; padding: 10px; min-height: 80px; }
            
            /* ë°”ë‹¥ ì˜ì—­ */
            .card-area { padding: 12px; min-height: 70px; border-width: 2px; }
            
            /* ë²„íŠ¼ - í„°ì¹˜í•˜ê¸° ì‰½ê²Œ */
            button { 
                padding: 14px 16px; 
                font-size: 14px; 
                margin: 3px;
                min-height: 48px;  /* í„°ì¹˜ ìµœì†Œ í¬ê¸° */
            }
            
            /* ìƒíƒœ í‘œì‹œ */
            #turn-status { padding: 10px; font-size: 1em; }
            #selection-info { padding: 8px; font-size: 0.9em; }
            
            /* ë¡œê·¸ */
            #log { height: 80px; font-size: 11px; padding: 10px; }
            
            /* ì±„íŒ… */
            #chat-messages { height: 100px; font-size: 12px; }
            #chat-input { padding: 12px; font-size: 16px; }
            #chat-send { padding: 12px 15px; }
            
            /* í‚¤ë³´ë“œ ë„ì›€ë§ ìˆ¨ê¹€ */
            .keyboard-help { display: none; }
            
            /* ê²°ê³¼ ëª¨ë‹¬ */
            #result-content { padding: 25px; margin: 10px; }
            #result-content h2 { font-size: 1.5em; }
            .rank-item { padding: 8px; gap: 10px; }
            .rank-number { font-size: 1.2em; width: 35px; }
            
            /* ê´€ì „ ë°°ë„ˆ */
            #spectator-banner { padding: 12px; font-size: 0.9em; }
            #spectator-banner button { margin-top: 8px; }
            
            /* ì°¸ê°€ ìš”ì²­ íŒ¨ë„ */
            #join-requests-panel { padding: 12px; font-size: 0.9em; }
        }
        
        /* ì•„ì£¼ ì‘ì€ í™”ë©´ (320px) */
        @media (max-width: 360px) {
            .card { width: 38px; height: 54px; font-size: 14px; }
            .hand { gap: 3px; }
            .opponent-card { min-width: 100px; padding: 8px 10px; }
            button { padding: 12px 10px; font-size: 13px; }
        }
        
        /* í„°ì¹˜ ë””ë°”ì´ìŠ¤ ì „ìš© */
        @media (hover: none) and (pointer: coarse) {
            .card:hover { transform: none; }
            .card[aria-pressed="true"]:hover { transform: translateY(-8px); }
            button:hover { background: inherit; }
            .btn-create:hover { background: #e94560; }
            .btn-join:hover { background: #0f3460; }
            .btn-pass:hover { background: #0f3460; }
            .btn-clear:hover { background: #6c5ce7; }
        }
        
        /* í† ìŠ¤íŠ¸ ì•Œë¦¼ */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toast {
            background: #e74c3c;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
        }
        .toast.info { background: #3498db; }
        .toast.warning { background: #e67e22; }
        .toast.success { background: #27ae60; }
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toastOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        /* ==================== ì €ì‹œë ¥ ì ‘ê·¼ì„± (ê³ ëŒ€ë¹„ ëª¨ë“œ) ==================== */
        body.high-contrast {
            background: #000;
        }
        body.high-contrast #lobby,
        body.high-contrast #game-container,
        body.high-contrast #result-content {
            background: #000;
            border: 3px solid #fff;
        }
        body.high-contrast .info-panel,
        body.high-contrast #opponents-area .opponent-card,
        body.high-contrast .hand,
        body.high-contrast #log,
        body.high-contrast #chat-container,
        body.high-contrast .tab-panel,
        body.high-contrast #players-list,
        body.high-contrast .rank-item {
            background: #000;
            border: 2px solid #fff;
        }
        body.high-contrast .card {
            background: #000;
            border: 4px solid #fff;
            color: #fff;
            font-size: 22px;
            width: 60px;
            height: 80px;
        }
        body.high-contrast .card[aria-pressed="true"] {
            background: #ffff00;
            color: #000;
            border-color: #ffff00;
            transform: translateY(-12px);
        }
        body.high-contrast .card[aria-pressed="true"]::after {
            content: "âœ“";
            position: absolute;
            top: -8px;
            right: -8px;
            background: #000;
            color: #ffff00;
            font-size: 16px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ffff00;
        }
        body.high-contrast .card {
            position: relative;
        }
        body.high-contrast .card.joker {
            border-color: #00ffff;
            color: #00ffff;
        }
        body.high-contrast .card.joker[aria-pressed="true"] {
            background: #00ffff;
            color: #000;
        }
        body.high-contrast .card.red-one {
            border-color: #ff0000;
            color: #ff0000;
        }
        body.high-contrast .card.red-one[aria-pressed="true"] {
            background: #ff0000;
            color: #fff;
        }
        body.high-contrast .card:focus {
            outline: 6px solid #00ff00;
            outline-offset: 4px;
        }
        body.high-contrast button {
            background: #fff;
            color: #000;
            border: 3px solid #000;
            font-weight: bold;
        }
        body.high-contrast button:hover,
        body.high-contrast button:focus {
            background: #ffff00;
            outline: 4px solid #00ff00;
        }
        body.high-contrast button:disabled {
            background: #666;
            color: #999;
        }
        body.high-contrast #turn-status.my-turn {
            background: #00ff00;
            color: #000;
            font-size: 1.3em;
        }
        body.high-contrast #turn-status.opponent-turn {
            background: #ff0000;
            color: #fff;
        }
        body.high-contrast h1,
        body.high-contrast h2,
        body.high-contrast .opponent-name,
        body.high-contrast .info-item strong {
            color: #ffff00;
        }
        body.high-contrast .opponent-card.current-turn {
            border: 5px solid #00ff00;
            background: #003300;
        }
        body.high-contrast #selection-info {
            background: #000;
            border: 3px solid #ffff00;
            color: #ffff00;
            font-size: 1.1em;
        }
        body.high-contrast .card-area {
            border: 4px solid #ffff00;
            background: #000;
        }
        body.high-contrast .tab-btn {
            background: #000;
            color: #fff;
            border: 2px solid #fff;
        }
        body.high-contrast .tab-btn.active,
        body.high-contrast .tab-btn[aria-selected="true"] {
            background: #ffff00;
            color: #000;
        }
        /* ê³ ëŒ€ë¹„ í† ê¸€ ë²„íŠ¼ */
        #accessibility-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            padding: 10px 15px;
            font-size: 14px;
            background: #333;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
        }
        #accessibility-toggle:focus {
            outline: 3px solid #ffc107;
        }
        body.high-contrast #accessibility-toggle {
            background: #ffff00;
            color: #000;
            border-color: #000;
        }
    </style>
</head>
<body>

<!-- ì—°ê²° ìƒíƒœ í‘œì‹œ -->
<div id="connection-status" class="offline" role="status" aria-live="polite">ì—°ê²° ì¤‘...</div>

<!-- í† ìŠ¤íŠ¸ ì•Œë¦¼ ì»¨í…Œì´ë„ˆ -->
<div id="toast-container" class="toast-container" aria-live="polite"></div>

<!-- ìŠ¤í¬ë¦° ë¦¬ë” ì•Œë¦¼ (ì´ì¤‘ ì˜ì—­ìœ¼ë¡œ í™•ì‹¤í•œ ì¶œë ¥) -->
<div id="live-announcer-1" class="sr-only" aria-live="polite" aria-atomic="true"></div>
<div id="live-announcer-2" class="sr-only" aria-live="polite" aria-atomic="true"></div>

<!-- ==================== ë¡œë¹„ í™”ë©´ ==================== -->
<div id="lobby" role="main" aria-labelledby="lobby-title">
    <h1 id="lobby-title">ğŸ² í”¼í¼ ì˜¨ë¼ì¸</h1>
    <p style="color:#aaa; margin-bottom:20px;">2~4ì¸ ë©€í‹°í”Œë ˆì´ì–´</p>
    
    <div id="lobby-main">
        <!-- ë‹‰ë„¤ì„ (ê³µí†µ) -->
        <label for="player-name" class="sr-only">ë‹‰ë„¤ì„</label>
        <input type="text" id="player-name" placeholder="ë‹‰ë„¤ì„ ì…ë ¥" maxlength="8" aria-required="true">
        
        <!-- íƒ­ ë©”ë‰´ -->
        <div class="tab-menu" role="tablist" aria-label="ê²Œì„ ë©”ë‰´">
            <button role="tab" 
                    id="tab-create" 
                    class="tab-btn active" 
                    aria-selected="true" 
                    aria-controls="panel-create"
                    tabindex="0">
                ğŸ® ëŒ€íšŒ ìƒì„±
            </button>
            <button role="tab" 
                    id="tab-join" 
                    class="tab-btn" 
                    aria-selected="false" 
                    aria-controls="panel-join"
                    tabindex="-1">
                ğŸšª ëŒ€íšŒ ì°¸ì—¬
            </button>
            <button role="tab" 
                    id="tab-spectate" 
                    class="tab-btn" 
                    aria-selected="false" 
                    aria-controls="panel-spectate"
                    tabindex="-1">
                ğŸ‘€ ê´€ì „
            </button>
            <button role="tab" 
                    id="tab-ai" 
                    class="tab-btn" 
                    aria-selected="false" 
                    aria-controls="panel-ai"
                    tabindex="-1">
                ğŸ¤– AI ëŒ€ì „
            </button>
        </div>
        
        <!-- ëŒ€íšŒ ìƒì„± íŒ¨ë„ -->
        <div role="tabpanel" id="panel-create" class="tab-panel" aria-labelledby="tab-create">
            <h2 class="panel-title">ìƒˆ ëŒ€íšŒ ë§Œë“¤ê¸°</h2>
            
            <label for="player-count" class="sr-only">ì°¸ê°€ ì¸ì›</label>
            <select id="player-count">
                <option value="2">2ëª…</option>
                <option value="3">3ëª…</option>
                <option value="4">4ëª…</option>
            </select>
            
            <label for="custom-room-code" class="sr-only">ë°© ì½”ë“œ ì§ì ‘ ì„¤ì • (ì„ íƒì‚¬í•­)</label>
            <input type="text" id="custom-room-code" placeholder="ë°© ì½”ë“œ ì§ì ‘ ì„¤ì • (ë¹„ìš°ë©´ ìë™ìƒì„±)" maxlength="6" style="text-transform: uppercase;">
            
            <button class="btn-create" onclick="createRoom()">ëŒ€íšŒ ìƒì„±</button>
        </div>
        
        <!-- ëŒ€íšŒ ì°¸ì—¬ íŒ¨ë„ -->
        <div role="tabpanel" id="panel-join" class="tab-panel" aria-labelledby="tab-join" style="display:none;" hidden>
            <h2 class="panel-title">ëŒ€íšŒ ì°¸ê°€í•˜ê¸°</h2>
            
            <label for="join-room-code" class="sr-only">ë°© ì½”ë“œ</label>
            <input type="text" id="join-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥ (ì˜ˆ: ABC123)" maxlength="6" style="text-transform: uppercase;">
            
            <button class="btn-join" onclick="joinRoom()">ì°¸ê°€í•˜ê¸°</button>
        </div>
        
        <!-- AI ëŒ€ì „ íŒ¨ë„ -->
        <div role="tabpanel" id="panel-ai" class="tab-panel" aria-labelledby="tab-ai" style="display:none;" hidden>
            <h2 class="panel-title">ğŸ¤– ì»´í“¨í„°ì™€ ëŒ€ì „</h2>
            <p style="color:#aaa; font-size:0.9em; margin-bottom:15px;">AIì™€ í•¨ê»˜ ëŒ€ì „í•©ë‹ˆë‹¤. (Firebase ì—°ë™)</p>
            
            <label for="ai-player-count" class="sr-only">AI ìˆ˜</label>
            <select id="ai-player-count">
                <option value="1">AI 1ëª… (1:1 ëŒ€ì „)</option>
                <option value="2">AI 2ëª… (3ì¸ ëŒ€ì „)</option>
                <option value="3">AI 3ëª… (4ì¸ ëŒ€ì „)</option>
            </select>
            
            <button class="btn-ai" onclick="startAIGame()" style="background:#9b59b6;">AI ëŒ€ì „ ì‹œì‘</button>
        </div>
        
        <!-- ê´€ì „ íŒ¨ë„ -->
        <div role="tabpanel" id="panel-spectate" class="tab-panel" aria-labelledby="tab-spectate" style="display:none;" hidden>
            <h2 class="panel-title">ê²½ê¸° ê´€ì „í•˜ê¸°</h2>
            <p style="color:#aaa; font-size:0.9em; margin-bottom:15px;">ì§„í–‰ ì¤‘ì¸ ê²½ê¸°ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê´€ëŒí•©ë‹ˆë‹¤</p>
            
            <label for="spectate-room-code" class="sr-only">ë°© ì½”ë“œ</label>
            <input type="text" id="spectate-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥ (ì˜ˆ: ABC123)" maxlength="6" style="text-transform: uppercase;">
            
            <button class="btn-spectate" onclick="joinAsSpectator()">ê´€ì „í•˜ê¸°</button>
        </div>
        
        <!-- ë°© ê´€ë¦¬ -->
        <div style="margin-top: 20px; padding: 15px; background: #1a1a2e; border-radius: 10px; border: 1px solid #444;">
            <h3 style="color: #e74c3c; margin: 0 0 10px 0; font-size: 0.95em;">ğŸ—‘ï¸ ë°© ê´€ë¦¬</h3>
            <label for="delete-room-code" class="sr-only">ì‚­ì œí•  ë°© ì½”ë“œ</label>
            <input type="text" id="delete-room-code" placeholder="ì‚­ì œí•  ë°© ì½”ë“œ" maxlength="6" style="text-transform: uppercase; width: 60%; display: inline-block;">
            <button onclick="deleteRoom()" style="background:#e74c3c; width: 35%; margin-left: 5%;">ì‚­ì œ</button>
            <p style="color:#888; font-size:0.8em; margin-top:8px;">ì´ì „ì— ë§Œë“  ë°©ì„ ì‚­ì œí•©ë‹ˆë‹¤</p>
            <hr style="border: none; border-top: 1px solid #444; margin: 15px 0;">
            <button onclick="deleteAllRooms()" style="background:#8b0000; width: 100%;">âš ï¸ ëª¨ë“  ë°© ì‚­ì œ</button>
            <p style="color:#ff6b6b; font-size:0.75em; margin-top:5px;">ì£¼ì˜: ëª¨ë“  ë°©ì´ ì‚­ì œë©ë‹ˆë‹¤!</p>
        </div>
    </div>
    
    <div id="lobby-waiting" style="display:none;">
        <h2 style="border:none; text-align:center;">ë°© ìƒì„± ì™„ë£Œ!</h2>
        <div id="room-code-display" aria-label="ë°© ì½”ë“œ">------</div>
        <p style="color:#aaa;">ì´ ì½”ë“œë¥¼ ì¹œêµ¬ì—ê²Œ ì•Œë ¤ì£¼ì„¸ìš”</p>
        
        <div id="players-list">
            <h3>ì°¸ê°€ì (<span id="current-player-count">1</span>/<span id="max-player-count">2</span>)</h3>
            <div id="players-container"></div>
        </div>
        
        <!-- ë°©ì¥ìš©: AI ì¶”ê°€ ë²„íŠ¼ -->
        <div id="ai-add-section" style="margin-top:15px; padding:10px; background:#2c3e50; border-radius:8px;">
            <button id="btn-add-ai" onclick="addAIPlayer()" style="background:#9b59b6; width:100%;">
                ğŸ¤– AI í”Œë ˆì´ì–´ ì¶”ê°€
            </button>
            <p style="color:#888; font-size:0.85em; margin-top:5px;">ë¹ˆ ìë¦¬ì— ì»´í“¨í„°ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤</p>
        </div>
        
        <div id="spectators-list" style="margin-top:10px;">
            <h3 style="color:#9b59b6;">ê´€ì „ì (<span id="spectator-count">0</span>ëª…)</h3>
            <div id="spectators-container"></div>
        </div>
        
        <p class="waiting-msg" role="status" aria-live="polite" id="waiting-message">ğŸ‘€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
        <button onclick="cancelRoom()" style="background:#e74c3c;">ì·¨ì†Œí•˜ê¸°</button>
    </div>
</div>

<!-- ==================== ê²Œì„ í™”ë©´ ==================== -->
<div id="game-container" role="main" aria-labelledby="game-title">
    
    <h1 id="game-title">ğŸ² í”¼í¼ ì˜¨ë¼ì¸</h1>
    
    <!-- ê´€ì „ ëª¨ë“œ ë°°ë„ˆ -->
    <div id="spectator-banner" style="display:none; background:#9b59b6; padding:15px; border-radius:10px; margin-bottom:15px;">
        <div>ğŸ‘€ <strong>ê´€ì „ ëª¨ë“œ</strong> - ê²½ê¸°ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ê´€ëŒ ì¤‘ì…ë‹ˆë‹¤</div>
        <button id="btn-request-join" onclick="requestJoinGame()" style="margin-top:10px; background:#2ecc71;">
            ğŸ® ê²Œì„ ì°¸ê°€ ìš”ì²­
        </button>
        <span id="request-status" style="margin-left:10px; display:none;">ìš”ì²­ ì¤‘...</span>
    </div>
    
    <!-- ë°©ì¥ìš©: ì°¸ê°€ ìš”ì²­ ëª©ë¡ -->
    <div id="join-requests-panel" style="display:none; background:#e74c3c; padding:15px; border-radius:10px; margin-bottom:15px;">
        <strong>ğŸ“‹ ì°¸ê°€ ìš”ì²­</strong>
        <div id="join-requests-list" style="margin-top:10px;"></div>
    </div>
    
    <!-- H2: ê²Œì„ í˜„í™© -->
    <h2 id="status-heading">ê²Œì„ í˜„í™©</h2>
    <div class="info-panel" role="region" aria-labelledby="status-heading">
        <div class="info-item">
            <strong>ë°© ì½”ë“œ</strong><br>
            <span id="game-room-code">------</span>
        </div>
        <div class="info-item">
            <strong>ì°¸ê°€ì</strong><br>
            <span id="game-player-count">2</span>ëª…
        </div>
        <div class="info-item" id="my-card-info">
            <strong>ë‚´ íŒ¨</strong><br>
            <span id="my-count">0</span>ì¥
        </div>
        <div class="info-item">
            <strong>ê´€ì „ì</strong><br>
            <span id="game-spectator-count">0</span>ëª…
        </div>
    </div>
    
    <!-- í„´ ìƒíƒœ (ìŠ¤í¬ë¦°ë¦¬ë”ëŠ” announceë¡œë§Œ ì•Œë¦¼) -->
    <div id="turn-status" class="waiting" aria-hidden="true">
        ê²Œì„ ì¤€ë¹„ ì¤‘...
    </div>
    
    <!-- H2: ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ -->
    <h2 id="opponents-heading">ë‹¤ë¥¸ í”Œë ˆì´ì–´</h2>
    <div id="opponents-area" role="region" aria-labelledby="opponents-heading">
        <!-- ë™ì  ìƒì„± -->
    </div>
    
    <!-- H2: í˜„ì¬ ë°”ë‹¥ -->
    <h2 id="table-heading" aria-hidden="true">ë°”ë‹¥</h2>
    <div class="card-area" id="table-area" role="region" aria-labelledby="table-heading" aria-hidden="true">
        <p id="table-description">ë°”ë‹¥ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.</p>
    </div>
    
    <!-- ì„ íƒí•œ ì¹´ë“œ (í”Œë ˆì´ì–´ ì „ìš©) -->
    <div id="player-controls">
        <h2 id="selection-heading" aria-hidden="true">ì„ íƒ</h2>
        <div id="selection-info" aria-hidden="true">
        </div>
        
        <!-- H2: ë‚´ íŒ¨ -->
        <h2 id="hand-heading">ë‚´ íŒ¨ (<span id="hand-count">0</span>ì¥)</h2>
        <div class="hand" id="player-hand" aria-labelledby="hand-heading">
        </div>
        
        <div class="keyboard-help" aria-hidden="true">
            [Tab: ì¹´ë“œ íƒìƒ‰] [â†â†’: ì´ë™] [Home/End: ì²˜ìŒ/ë] [Space: ì„ íƒ] [Alt+P: ë‚´ê¸°] [Alt+X: íŒ¨ìŠ¤] [Alt+C: ì·¨ì†Œ] [Alt+S: ìƒí™©] [Alt+M: ë§ˆì¸] [Alt+R: ë¦¬í„´] [Alt+T: ì±„íŒ…] [Alt+L: ìµœê·¼ ì±„íŒ…] [Alt+Q: ì‚¬ìš´ë“œ]
        </div>
        
        <!-- H2: ê²Œì„ ì¡°ì‘ -->
        <h2 id="controls-heading">ê²Œì„ ì¡°ì‘</h2>
        <div role="group" aria-labelledby="controls-heading">
            <button id="btn-play" onclick="playMove()">ì¹´ë“œ ë‚´ê¸° (Alt+P)</button>
            <button id="btn-pass" class="btn-pass" onclick="passTurn()">íŒ¨ìŠ¤ (Alt+X)</button>
            <button id="btn-clear" class="btn-clear" onclick="clearSelection()">ì„ íƒ ì·¨ì†Œ (Alt+C)</button>
            <button id="btn-mine" tabindex="0" onclick="autoMine()" style="background:#9b59b6; display:none;">ğŸ’£ ë§ˆì¸ (Alt+M)</button>
            <button id="btn-call" tabindex="0" onclick="callCards()" style="background:#e67e22; display:none;">ğŸ“¢ 3ì¹´ë“œ!</button>
        </div>
        
        <!-- ë¦¬í„´ ë²„íŠ¼ (ë§ˆì¸ ë°œìƒ ì‹œ í‘œì‹œ) -->
        <div id="return-panel" style="display:none; margin-top:15px; padding:15px; background:#e74c3c; border-radius:10px;">
            <div id="return-message" style="font-weight:bold; margin-bottom:10px;"></div>
            <button id="btn-return" tabindex="0" onclick="doReturn()" style="background:#27ae60; font-size:1.2em; padding:15px 30px;">
                ğŸ”„ ë¦¬í„´í•˜ê¸° (Alt+R)
            </button>
            <div id="return-timer" style="margin-top:10px; font-size:1.1em;"></div>
        </div>
    </div>
    
    <!-- H2: ê²Œì„ ë¡œê·¸ -->
    <h2 id="log-heading">ì§„í–‰ ê¸°ë¡</h2>
    <div id="log" aria-labelledby="log-heading"></div>
    
    <!-- H2: ì±„íŒ… -->
    <h2 id="chat-heading">ì±„íŒ… <span style="font-size:0.7em; color:#888; font-weight:normal;">(Alt+T: ì…ë ¥, Alt+L: ì½ê¸°)</span></h2>
    <div id="chat-container">
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <label for="chat-input" class="sr-only">ì±„íŒ… ë©”ì‹œì§€ ì…ë ¥</label>
            <input type="text" id="chat-input" placeholder="ë©”ì‹œì§€ ì…ë ¥..." autocomplete="off">
            <button id="chat-send" onclick="sendChat()">ì „ì†¡</button>
        </div>
    </div>
    
    <div style="margin-top:15px;">
        <button id="sound-toggle" onclick="toggleSound()" style="background:#27ae60;" aria-label="ì‚¬ìš´ë“œ ì¼œì§">ğŸ”Š ì‚¬ìš´ë“œ ì¼œì§</button>
        <button onclick="leaveGame()" style="background:#e74c3c;">ê²Œì„ ë‚˜ê°€ê¸°</button>
    </div>
</div>

<!-- ==================== ê²°ê³¼ ëª¨ë‹¬ ==================== -->
<div id="result-modal" role="dialog" aria-labelledby="result-title" aria-modal="true">
    <div id="result-content">
        <h2 id="result-title">ê²Œì„ ì¢…ë£Œ</h2>
        <div id="rankings"></div>
        <p id="result-message"></p>
        <button onclick="playAgain()">ë‹¤ì‹œ í•˜ê¸°</button>
        <button onclick="backToLobby()" style="background:#0f3460;">ë¡œë¹„ë¡œ</button>
    </div>
</div>

<!-- ==================== Firebase SDK ==================== -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getDatabase, ref, set, get, update, remove, onValue, onDisconnect, serverTimestamp 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

    // Firebase ì„¤ì •
    const firebaseConfig = {
        apiKey: "AIzaSyBuqOhMraxvfUW-KED-vY8MYRvvwB1NDCQA",
        authDomain: "peeper-game.firebaseapp.com",
        databaseURL: "https://peeper-game-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "peeper-game",
        storageBucket: "peeper-game.firebasestorage.app",
        messagingSenderId: "997321057268",
        appId: "1:997321057268:web:57c3c02a83d62578e5cfa1"
    };

    let app, db;
    let isFirebaseReady = false;
    
    try {
        app = initializeApp(firebaseConfig);
        db = getDatabase(app);
        isFirebaseReady = true;
        updateConnectionStatus(true);
    } catch (error) {
        console.error("Firebase ì—°ê²° ì‹¤íŒ¨:", error);
        updateConnectionStatus(false);
    }

    // ==================== ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ====================
    let currentRoom = null;
    let myPlayerId = null;
    let myName = "";
    let maxPlayers = 2;
    let players = {};  // { player1: {name, hand, connected, finished, rank}, ... }
    let spectators = {};  // { odsfj3: {name, odsfj3}, ... }
    let isSpectator = false;  // ê´€ì „ì ì—¬ë¶€
    let mySpectatorId = null;  // ê´€ì „ì ID
    let myHand = [];
    let lastMove = null;
    let currentTurn = null;
    let selectedIndices = [];
    let currentFocusIndex = 0;
    let roomListener = null;
    let chatListener = null;  // ì±„íŒ… ë¦¬ìŠ¤ë„ˆ
    let finishedPlayers = [];  // ì™„ì£¼ ìˆœì„œ
    let prevOpponentHandCounts = {};  // ìƒëŒ€ë°© ì´ì „ íŒ¨ ê°œìˆ˜ ì¶”ì 
    let prevPassedBy = null;  // ì´ì „ íŒ¨ìŠ¤í•œ í”Œë ˆì´ì–´ ì¶”ì 
    let joinRequests = {};  // ì°¸ê°€ ìš”ì²­ ëª©ë¡
    let prevGameStatus = null;  // ì´ì „ ê²Œì„ ìƒíƒœ ì¶”ì 
    
    // AI ê´€ë ¨ ë³€ìˆ˜
    let isAIGame = false;
    let aiThinking = false;  // AI ì²˜ë¦¬ ì¤‘ë³µ ë°©ì§€
    let skipNextGameAnnounce = false;  // ì±„íŒ… ì•Œë¦¼ í›„ ê²Œì„ ì•Œë¦¼ ìŠ¤í‚µ
    let isProcessing = false;  // ì¹´ë“œ ë‚´ê¸°/íŒ¨ìŠ¤ ì²˜ë¦¬ ì¤‘
    let skipFocusRestore = false;  // ì¹´ë“œ ë‚¸ í›„ í¬ì»¤ìŠ¤ ë³µì› ì•ˆ í•¨
    
    // ë§ˆì¸/ë¦¬í„´ ê´€ë ¨ ë³€ìˆ˜
    let mineState = null;  // { val: 8, mineBy: 'player2', timer: null }
    const RETURN_WAIT_TIME = 3;   // ë¦¬í„´ ëŒ€ê¸° ì‹œê°„ (ì´ˆ) - ë§ˆì¸ í›„ ë¦¬í„´ ê¸°íšŒ
    const AI_TURN_DELAY = 1000;    // AI í„´ ê¸°ë³¸ ë”œë ˆì´ (3ì´ˆ)
    const AI_TURN_RANDOM = 500;   // AI í„´ ëœë¤ ì¶”ê°€ ë”œë ˆì´ (0~2ì´ˆ) â†’ ì´ 3~5ì´ˆ

    // ì „ì—­ í•¨ìˆ˜ ë…¸ì¶œ
    window.createRoom = createRoom;
    window.joinRoom = joinRoom;
    window.joinAsSpectator = joinAsSpectator;
    window.cancelRoom = cancelRoom;
    window.playMove = playMove;
    window.passTurn = passTurn;
    window.clearSelection = clearSelection;
    window.leaveGame = leaveGame;
    window.playAgain = playAgain;
    window.backToLobby = backToLobby;
    window.sendChat = sendChat;
    window.requestJoinGame = requestJoinGame;
    window.approveJoinRequest = approveJoinRequest;
    window.rejectJoinRequest = rejectJoinRequest;
    window.inviteSpectator = inviteSpectator;
    window.switchTab = switchTab;
    window.startAIGame = startAIGame;
    window.addAIPlayer = addAIPlayer;
    window.doReturn = doReturn;
    window.callCards = callCards;
    window.autoMine = autoMine;
    window.deleteRoom = deleteRoom;

    // ==================== ë°© ì‚­ì œ ====================
    async function deleteRoom() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }
        
        const roomCode = document.getElementById('delete-room-code').value.trim().toUpperCase();
        if (!roomCode) {
            alert("ì‚­ì œí•  ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }
        
        try {
            const snapshot = await get(ref(db, `rooms/${roomCode}`));
            if (!snapshot.exists()) {
                alert("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°©ì…ë‹ˆë‹¤.");
                return;
            }
            
            if (confirm(`ë°© "${roomCode}"ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`)) {
                await remove(ref(db, `rooms/${roomCode}`));
                document.getElementById('delete-room-code').value = '';
                alert(`ë°© "${roomCode}"ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                announce('ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error("ë°© ì‚­ì œ ì‹¤íŒ¨:", error);
            alert("ë°© ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }
    
    // ëª¨ë“  ë°© ì‚­ì œ
    async function deleteAllRooms() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }
        
        try {
            const snapshot = await get(ref(db, 'rooms'));
            if (!snapshot.exists()) {
                alert("ì‚­ì œí•  ë°©ì´ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }
            
            const rooms = snapshot.val();
            const roomCount = Object.keys(rooms).length;
            
            if (confirm(`âš ï¸ ì •ë§ë¡œ ëª¨ë“  ë°©(${roomCount}ê°œ)ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìœ¼ë©°, ì§„í–‰ ì¤‘ì¸ ëª¨ë“  ê²Œì„ì´ ì¢…ë£Œë©ë‹ˆë‹¤.`)) {
                if (confirm(`ë§ˆì§€ë§‰ í™•ì¸: ${roomCount}ê°œì˜ ë°©ì„ ëª¨ë‘ ì‚­ì œí•©ë‹ˆë‹¤.\n\nì •ë§ ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    await remove(ref(db, 'rooms'));
                    alert(`${roomCount}ê°œì˜ ë°©ì´ ëª¨ë‘ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    announce('ëª¨ë“  ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                }
            }
        } catch (error) {
            console.error("ì „ì²´ ë°© ì‚­ì œ ì‹¤íŒ¨:", error);
            alert("ë°© ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }
    window.deleteAllRooms = deleteAllRooms;

    // ==================== íƒ­ ë©”ë‰´ ====================
    const tabNames = {
        'create': 'ëŒ€íšŒ ìƒì„±',
        'join': 'ëŒ€íšŒ ì°¸ì—¬', 
        'spectate': 'ê´€ì „',
        'ai': 'AI ëŒ€ì „'
    };
    
    function switchTab(tabId) {
        const tabs = document.querySelectorAll('.tab-btn');
        const panels = document.querySelectorAll('.tab-panel');
        
        // ëª¨ë“  íƒ­ ë¹„í™œì„±í™”
        tabs.forEach(tab => {
            tab.classList.remove('active');
            tab.setAttribute('aria-selected', 'false');
            tab.setAttribute('tabindex', '-1');
        });
        
        // ëª¨ë“  íŒ¨ë„ ìˆ¨ê¸°ê¸°
        panels.forEach(panel => {
            panel.style.display = 'none';
            panel.setAttribute('hidden', '');
        });
        
        // ì„ íƒëœ íƒ­ í™œì„±í™”
        const selectedTab = document.getElementById(`tab-${tabId}`);
        const selectedPanel = document.getElementById(`panel-${tabId}`);
        
        if (selectedTab && selectedPanel) {
            selectedTab.classList.add('active');
            selectedTab.setAttribute('aria-selected', 'true');
            selectedTab.setAttribute('tabindex', '0');
            selectedPanel.style.display = 'block';
            selectedPanel.removeAttribute('hidden');
            
            // ìŠ¤í¬ë¦° ë¦¬ë” ì•Œë¦¼
            // announce ì œê±°
        }
    }
    
    // íƒ­ í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', () => {
        const tabList = document.querySelector('.tab-menu');
        if (!tabList) return;
        
        tabList.addEventListener('keydown', (e) => {
            const tabs = Array.from(document.querySelectorAll('.tab-btn'));
            const currentTab = document.activeElement;
            const currentIndex = tabs.indexOf(currentTab);
            
            if (currentIndex === -1) return;
            
            let newIndex = currentIndex;
            
            switch (e.key) {
                case 'ArrowLeft':
                case 'ArrowUp':
                    e.preventDefault();
                    newIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                    break;
                case 'ArrowRight':
                case 'ArrowDown':
                    e.preventDefault();
                    newIndex = (currentIndex + 1) % tabs.length;
                    break;
                case 'Home':
                    e.preventDefault();
                    newIndex = 0;
                    break;
                case 'End':
                    e.preventDefault();
                    newIndex = tabs.length - 1;
                    break;
                case 'Enter':
                case ' ':
                    e.preventDefault();
                    const tabId = currentTab.id.replace('tab-', '');
                    switchTab(tabId);
                    return;
                default:
                    return;
            }
            
            // í¬ì»¤ìŠ¤ ì´ë™ ë° íƒ­ ì „í™˜
            const newTab = tabs[newIndex];
            const newTabId = newTab.id.replace('tab-', '');
            switchTab(newTabId);
            newTab.focus();
        });
        
        // íƒ­ í´ë¦­ ì´ë²¤íŠ¸
        document.querySelectorAll('.tab-btn').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.id.replace('tab-', '');
                switchTab(tabId);
            });
            
            // íƒ­ í¬ì»¤ìŠ¤ ì‹œ ì„ íƒ ìƒíƒœ ì•Œë¦¼
            tab.addEventListener('focus', () => {
                const tabId = tab.id.replace('tab-', '');
                const isSelected = tab.getAttribute('aria-selected') === 'true';
                announce(`${tabNames[tabId]} íƒ­${isSelected ? ', ì„ íƒë¨' : ''}`);
            });
        });
    });

    // ==================== ìœ í‹¸ë¦¬í‹° ====================
    function updateConnectionStatus(online) {
        const status = document.getElementById('connection-status');
        status.className = online ? 'online' : 'offline';
        status.textContent = online ? 'ì˜¨ë¼ì¸' : 'ì˜¤í”„ë¼ì¸';
    }

    // ==================== ì‚¬ìš´ë“œ íš¨ê³¼ ====================
    let audioContext = null;
    let soundEnabled = true;
    
    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    }
    
    function playSound(type) {
        if (!soundEnabled) return;
        
        try {
            const ctx = initAudio();
            if (ctx.state === 'suspended') ctx.resume();
            
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            // ì‚¬ìš´ë“œ íƒ€ì…ë³„ ì„¤ì •
            switch(type) {
                case 'play': // ë‚´ê°€ ì¹´ë“œ ë‚¼ ë•Œ - ì§§ì€ ìƒìŠ¹ìŒ
                    oscillator.frequency.setValueAtTime(440, ctx.currentTime);
                    oscillator.frequency.setValueAtTime(550, ctx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.2);
                    break;
                    
                case 'opponent': // ìƒëŒ€ë°© ì¹´ë“œ ë‚¼ ë•Œ - ë‚®ì€ í†¤
                    oscillator.frequency.setValueAtTime(330, ctx.currentTime);
                    oscillator.frequency.setValueAtTime(280, ctx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.25, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.2);
                    break;
                    
                case 'warning': // ì¹´ë“œ 3ì¥ ë‚¨ìŒ - ê²½ê³ ìŒ (3ë²ˆ ë¹„í”„)
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(800, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, ctx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.25);
                    gainNode.gain.setValueAtTime(0.2, ctx.currentTime + 0.3);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.4);
                    break;
                    
                case 'gameover': // ê²Œì„ ì¢…ë£Œ - íŒ¡íŒŒë ˆ
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(523, ctx.currentTime);        // C5
                    oscillator.frequency.setValueAtTime(659, ctx.currentTime + 0.15); // E5
                    oscillator.frequency.setValueAtTime(784, ctx.currentTime + 0.3);  // G5
                    oscillator.frequency.setValueAtTime(1047, ctx.currentTime + 0.45);// C6
                    gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.7);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.7);
                    break;
                    
                case 'chat': // ì±„íŒ… ë©”ì‹œì§€ - ë¶€ë“œëŸ¬ìš´ ì•Œë¦¼ìŒ
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(600, ctx.currentTime);
                    oscillator.frequency.setValueAtTime(800, ctx.currentTime + 0.08);
                    gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.15);
                    break;
                    
                case 'myturn': // ë‚´ ì°¨ë¡€ - ì•Œë¦¼ìŒ
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, ctx.currentTime);
                    oscillator.frequency.setValueAtTime(660, ctx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(880, ctx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.25, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 0.3);
                    break;
                    
                case 'gamestart': // ê²Œì„ ì‹œì‘ - ì¶œë°œ ì‹ í˜¸ìŒ
                    oscillator.type = 'sine';
                    // ì‚-ì‚-ì‚-ì‚ì‚! (3ë²ˆ ì§§ê²Œ + 1ë²ˆ ê¸¸ê²Œ)
                    oscillator.frequency.setValueAtTime(440, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0.25, ctx.currentTime);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.25, ctx.currentTime + 0.25);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.4);
                    gainNode.gain.setValueAtTime(0.25, ctx.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime + 0.65);
                    oscillator.frequency.setValueAtTime(880, ctx.currentTime + 0.75);
                    gainNode.gain.setValueAtTime(0.3, ctx.currentTime + 0.75);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.1);
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + 1.1);
                    break;
            }
        } catch (e) {
            console.log('ì‚¬ìš´ë“œ ì¬ìƒ ì‹¤íŒ¨:', e);
        }
    }
    
    // ì‚¬ìš´ë“œ í† ê¸€
    function toggleSound() {
        soundEnabled = !soundEnabled;
        const btn = document.getElementById('sound-toggle');
        if (btn) {
            btn.textContent = soundEnabled ? 'ğŸ”Š ì‚¬ìš´ë“œ ì¼œì§' : 'ğŸ”‡ ì‚¬ìš´ë“œ êº¼ì§';
            btn.style.background = soundEnabled ? '#27ae60' : '#95a5a6';
            btn.setAttribute('aria-label', soundEnabled ? 'ì‚¬ìš´ë“œ ì¼œì§' : 'ì‚¬ìš´ë“œ êº¼ì§');
        }
        announce(soundEnabled ? 'ì‚¬ìš´ë“œ ì¼œì§' : 'ì‚¬ìš´ë“œ êº¼ì§');
    }
    window.toggleSound = toggleSound;

    // ê³ ëŒ€ë¹„ ëª¨ë“œ í† ê¸€
    function toggleHighContrast() {
        document.body.classList.toggle('high-contrast');
        const isHigh = document.body.classList.contains('high-contrast');
        const btn = document.getElementById('accessibility-toggle');
        if (btn) {
            btn.textContent = isHigh ? 'ğŸ‘ï¸ ì¼ë°˜ ëª¨ë“œ' : 'ğŸ‘ï¸ ê³ ëŒ€ë¹„';
            btn.setAttribute('aria-label', isHigh ? 'ì¼ë°˜ ëª¨ë“œë¡œ ì „í™˜' : 'ê³ ëŒ€ë¹„ ëª¨ë“œë¡œ ì „í™˜');
        }
        announce(isHigh ? 'ê³ ëŒ€ë¹„ ëª¨ë“œ ì¼œì§' : 'ì¼ë°˜ ëª¨ë“œ');
        // ì„¤ì • ì €ì¥
        localStorage.setItem('highContrast', isHigh ? 'true' : 'false');
    }
    window.toggleHighContrast = toggleHighContrast;
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ê³ ëŒ€ë¹„ ì„¤ì • ë³µì›
    if (localStorage.getItem('highContrast') === 'true') {
        document.body.classList.add('high-contrast');
        const btn = document.getElementById('accessibility-toggle');
        if (btn) {
            btn.textContent = 'ğŸ‘ï¸ ì¼ë°˜ ëª¨ë“œ';
            btn.setAttribute('aria-label', 'ì¼ë°˜ ëª¨ë“œë¡œ ì „í™˜');
        }
    }

    let currentAnnouncer = 1;  // 1 ë˜ëŠ” 2 ë²ˆê°ˆì•„ ì‚¬ìš©
    
    // ê²Œì„ ì¤‘ ì¶œë ¥í•  ë©”ì‹œì§€ íŒ¨í„´
    function shouldAnnounce(message) {
        if (!message) return false;
        
        // ì¹´ë“œ ì„ íƒ/í•´ì œ
        if (message.includes('ì„ íƒ') || message.includes('í•´ì œ')) return true;
        
        // ì¹´ë“œ ë‚´ê¸° (ë‚˜: ~, ë‹‰ë„¤ì„: ~)
        if (message.includes(': ')) {
            const afterColon = message.split(': ')[1];
            // ì‹±ê¸€, í˜ì–´, ìŠ¤íŠ¸ë ˆì´íŠ¸, ë°¤, ë§ˆì¸, ë¦¬í„´, íŒ¨ìŠ¤, 3ì¹´ë“œ
            if (afterColon && (
                afterColon.includes('ì‹±ê¸€') ||
                afterColon.includes('í˜ì–´') ||
                afterColon.includes('ìŠ¤íŠ¸ë ˆì´íŠ¸') ||
                afterColon.includes('ë°¤') ||
                afterColon.includes('ë§ˆì¸') ||
                afterColon.includes('ë¦¬í„´') ||
                afterColon.includes('3ì¹´ë“œ') ||
                afterColon === 'íŒ¨ìŠ¤'
            )) return true;
            // ì±„íŒ… ë©”ì‹œì§€ (ìœ„ íŒ¨í„´ì— ì•ˆ ë§ìœ¼ë©´ ì±„íŒ…)
            return true;
        }
        // ë§ˆì¸/ë¦¬í„´ ì•Œë¦¼
        if (message.includes('ë§ˆì¸') || message.includes('ë¦¬í„´')) return true;
        // ê²Œì„ ê²°ê³¼
        if (message.includes('ë“±') || message.includes('ê²½ê¸° ì¢…ë£Œ')) return true;
        // ìƒíƒœ ì •ë³´ (ë‚´ íŒ¨, ë°”ë‹¥, ì°¨ë¡€)
        if (message.includes('ë‚´ íŒ¨') || message.includes('ë°”ë‹¥') || message.includes('ì°¨ë¡€')) return true;
        return false;
    }
    
    let lastAnnounceMessage = '';
    let lastAnnounceTime = 0;
    
    function announce(message) {
        // í•„í„°ë§
        if (!shouldAnnounce(message)) return;
        
        // ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€ (ê°™ì€ ë©”ì‹œì§€ê°€ 500ms ë‚´ì— ë˜ ì˜¤ë©´ ë¬´ì‹œ)
        const now = Date.now();
        if (message === lastAnnounceMessage && now - lastAnnounceTime < 500) {
            return;
        }
        lastAnnounceMessage = message;
        lastAnnounceTime = now;
        
        // ë‹¤ìŒ announcerë¡œ ì „í™˜
        currentAnnouncer = currentAnnouncer === 1 ? 2 : 1;
        const announcer = document.getElementById(`live-announcer-${currentAnnouncer}`);
        
        // ë©”ì‹œì§€ ì„¤ì •
        announcer.textContent = message;
    }
    
    // í† ìŠ¤íŠ¸ ì•Œë¦¼ (3ì´ˆ í›„ ìë™ ë‹«í˜)
    function showToast(message, type = 'warning') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        container.appendChild(toast);
        
        // 3ì´ˆ í›„ ì œê±°
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }

    function generateRoomCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 6; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));
        return code;
    }

    function createShuffledDeck() {
        const deck = [];
        for (let i = 1; i <= 16; i++) {
            for (let j = 0; j < 4; j++) {
                // 1ë²ˆ ì¹´ë“œ ì¤‘ ì²« ë²ˆì§¸(j=0)ë¥¼ ë¹¨ê°„ìƒ‰ 1ë¡œ í‘œì‹œ (1.1)
                if (i === 1 && j === 0) {
                    deck.push(1.1);  // ë¹¨ê°„ìƒ‰ 1
                } else {
                    deck.push(i);
                }
            }
        }
        // ì„ê¸°
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    }
    
    // ì¹´ë“œ ì‹¤ì œ ê°’ (ê²Œì„ ë¡œì§ìš©)
    function getCardValue(card) {
        return Math.floor(card);
    }
    
    // ë¹¨ê°„ìƒ‰ 1ì¸ì§€ í™•ì¸
    function isRedOne(card) {
        return card === 1.1;
    }

    // ì¹´ë“œ ë¶„ë°° + ë¹¨ê°„ìƒ‰ 1 ê°€ì§„ í”Œë ˆì´ì–´ ì°¾ê¸°
    function distributeCardsWithFirst(playerCount) {
        const deck = createShuffledDeck();
        const cardsPerPlayer = Math.floor(64 / playerCount);
        const hands = {};
        let firstPlayer = 'player1';
        
        for (let i = 1; i <= playerCount; i++) {
            const start = (i - 1) * cardsPerPlayer;
            const end = i * cardsPerPlayer;
            const hand = deck.slice(start, end).sort((a, b) => getCardValue(a) - getCardValue(b));
            hands[`player${i}`] = hand;
            
            // ë¹¨ê°„ìƒ‰ 1ì„ ê°€ì§„ í”Œë ˆì´ì–´ ì°¾ê¸°
            if (hand.some(c => isRedOne(c))) {
                firstPlayer = `player${i}`;
            }
        }
        
        return { hands, firstPlayer };
    }

    // ==================== ë°© ìƒì„± ====================
    async function createRoom() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }

        myName = document.getElementById('player-name').value.trim() || 'ë°©ì¥';
        maxPlayers = parseInt(document.getElementById('player-count').value);
        
        // ì»¤ìŠ¤í…€ ë°© ì½”ë“œ ë˜ëŠ” ìë™ ìƒì„±
        let customCode = document.getElementById('custom-room-code').value.trim().toUpperCase();
        let roomCode;
        
        if (customCode) {
            // ì»¤ìŠ¤í…€ ì½”ë“œ ìœ íš¨ì„± ê²€ì‚¬ (ì˜ë¬¸, ìˆ«ìë§Œ í—ˆìš©)
            if (!/^[A-Z0-9]{1,6}$/.test(customCode)) {
                alert("ë°© ì½”ë“œëŠ” ì˜ë¬¸ê³¼ ìˆ«ìë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. (ìµœëŒ€ 6ìë¦¬)");
                return;
            }
            roomCode = customCode;
            
            // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°©ì¸ì§€ í™•ì¸
            const existingRoom = await get(ref(db, `rooms/${roomCode}`));
            if (existingRoom.exists()) {
                alert("ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë°© ì½”ë“œì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                return;
            }
        } else {
            roomCode = generateRoomCode();
        }
        
        myPlayerId = 'player1';
        currentRoom = roomCode;

        try {
            await set(ref(db, `rooms/${roomCode}`), {
                code: roomCode,
                status: 'waiting',
                maxPlayers: maxPlayers,
                createdAt: serverTimestamp(),
                players: {
                    player1: {
                        name: myName,
                        connected: true,
                        finished: false,
                        rank: 0
                    }
                },
                gameState: null
            });

            onDisconnect(ref(db, `rooms/${roomCode}/players/player1/connected`)).set(false);

            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('max-player-count').textContent = maxPlayers;
            
            announce(`ë°©ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ë°© ì½”ë“œ ${roomCode.split('').join(' ')}. ${maxPlayers}ì¸ ê²Œì„.`);

            watchRoom(roomCode);

        } catch (error) {
            console.error("ë°© ìƒì„± ì‹¤íŒ¨:", error);
            alert("ë°© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }

    // ==================== ë°© ì°¸ê°€ ====================
    async function joinRoom() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }

        const roomCode = document.getElementById('join-room-code').value.trim().toUpperCase();
        if (!roomCode || roomCode.length < 1 || roomCode.length > 6) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”. (1~6ìë¦¬)");
            return;
        }

        myName = document.getElementById('player-name').value.trim() || 'í”Œë ˆì´ì–´';
        currentRoom = roomCode;

        try {
            const snapshot = await get(ref(db, `rooms/${roomCode}`));

            if (!snapshot.exists()) {
                alert("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°©ì…ë‹ˆë‹¤.");
                return;
            }

            const roomData = snapshot.val();
            
            // ë‹‰ë„¤ì„ìœ¼ë¡œ ê¸°ì¡´ í”Œë ˆì´ì–´ ì°¾ê¸° (ì¬ì ‘ì† ì‹œë„)
            const existingPlayers = roomData.players || {};
            let existingPlayerId = null;
            for (const [id, player] of Object.entries(existingPlayers)) {
                if (player.name === myName && !player.isAI) {
                    existingPlayerId = id;
                    break;
                }
            }
            
            // ì¬ì ‘ì† ì²˜ë¦¬
            if (existingPlayerId) {
                myPlayerId = existingPlayerId;
                maxPlayers = roomData.maxPlayers;
                
                // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
                await update(ref(db, `rooms/${roomCode}/players/${myPlayerId}`), {
                    connected: true
                });
                
                onDisconnect(ref(db, `rooms/${roomCode}/players/${myPlayerId}/connected`)).set(false);
                
                document.getElementById('lobby-main').style.display = 'none';
                
                if (roomData.status === 'playing') {
                    document.getElementById('lobby').style.display = 'none';
                    document.getElementById('game-container').style.display = 'block';
                    announce("ê²Œì„ì— ì¬ì ‘ì†í–ˆìŠµë‹ˆë‹¤.");
                } else {
                    document.getElementById('lobby-waiting').style.display = 'block';
                    document.getElementById('room-code-display').textContent = roomCode;
                    document.getElementById('max-player-count').textContent = maxPlayers;
                    announce("ë°©ì— ì¬ì ‘ì†í–ˆìŠµë‹ˆë‹¤.");
                }
                
                watchRoom(roomCode);
                return;
            }
            
            // ìƒˆ í”Œë ˆì´ì–´ ì°¸ê°€
            if (roomData.status !== 'waiting') {
                alert("ì´ë¯¸ ê²Œì„ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ê°™ì€ ë‹‰ë„¤ì„ìœ¼ë¡œ ì¬ì ‘ì†í•˜ë ¤ë©´ ê¸°ì¡´ ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”.");
                return;
            }

            // ë¹ˆ ìŠ¬ë¡¯ ì°¾ê¸°
            const playerCount = Object.keys(existingPlayers).length;
            if (playerCount >= roomData.maxPlayers) {
                alert("ë°©ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤.");
                return;
            }

            // ë‹¤ìŒ í”Œë ˆì´ì–´ ID í• ë‹¹
            let nextPlayerNum = 1;
            while (roomData.players?.[`player${nextPlayerNum}`]) {
                nextPlayerNum++;
            }
            myPlayerId = `player${nextPlayerNum}`;
            maxPlayers = roomData.maxPlayers;

            // ì°¸ê°€
            await update(ref(db, `rooms/${roomCode}/players`), {
                [myPlayerId]: {
                    name: myName,
                    connected: true,
                    finished: false,
                    rank: 0
                }
            });

            onDisconnect(ref(db, `rooms/${roomCode}/players/${myPlayerId}/connected`)).set(false);

            // ì¸ì›ì´ ë‹¤ ì°¼ìœ¼ë©´ ê²Œì„ ì‹œì‘
            const updatedSnapshot = await get(ref(db, `rooms/${roomCode}/players`));
            const currentPlayerCount = Object.keys(updatedSnapshot.val() || {}).length;

            if (currentPlayerCount >= maxPlayers) {
                // ê²Œì„ ì‹œì‘ - ì¹´ë“œ ë¶„ë°° ë° ì„  ì •í•˜ê¸°
                const { hands, firstPlayer } = distributeCardsWithFirst(maxPlayers);
                await update(ref(db, `rooms/${roomCode}`), {
                    status: 'playing',
                    gameState: {
                        hands: hands,
                        currentTurn: firstPlayer,
                        lastMove: null,
                        lastMoveBy: null,
                        passCount: 0,
                        finishedOrder: []
                    }
                });
            }

            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('max-player-count').textContent = maxPlayers;

            announce("ë°©ì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤.");
            watchRoom(roomCode);

        } catch (error) {
            console.error("ë°© ì°¸ê°€ ì‹¤íŒ¨:", error);
            alert("ë°© ì°¸ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }

    // ==================== ê´€ì „ìë¡œ ì°¸ê°€ ====================
    async function joinAsSpectator() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }

        const roomCode = document.getElementById('spectate-room-code').value.trim().toUpperCase();
        if (!roomCode || roomCode.length < 1 || roomCode.length > 6) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        myName = document.getElementById('player-name').value.trim() || 'ê´€ì „ì';
        currentRoom = roomCode;
        isSpectator = true;

        try {
            const snapshot = await get(ref(db, `rooms/${roomCode}`));

            if (!snapshot.exists()) {
                alert("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°©ì…ë‹ˆë‹¤.");
                isSpectator = false;
                return;
            }

            const roomData = snapshot.val();
            maxPlayers = roomData.maxPlayers;

            // ê´€ì „ì ID ìƒì„± (ëœë¤)
            mySpectatorId = 'spec_' + Math.random().toString(36).substr(2, 9);

            // ê´€ì „ìë¡œ ë“±ë¡
            await update(ref(db, `rooms/${roomCode}/spectators`), {
                [mySpectatorId]: {
                    name: myName,
                    joinedAt: serverTimestamp()
                }
            });

            // ì—°ê²° ëŠê¹€ ì²˜ë¦¬
            onDisconnect(ref(db, `rooms/${roomCode}/spectators/${mySpectatorId}`)).remove();

            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('room-code-display').textContent = roomCode;
            document.getElementById('max-player-count').textContent = maxPlayers;

            announce(`${roomCode} ë°©ì— ê´€ì „ìë¡œ ì°¸ê°€í–ˆìŠµë‹ˆë‹¤.`);
            watchRoom(roomCode);

        } catch (error) {
            console.error("ê´€ì „ ì°¸ê°€ ì‹¤íŒ¨:", error);
            alert("ê´€ì „ ì°¸ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
            isSpectator = false;
        }
    }

    // ==================== ë°© ê°ì‹œ ====================
    function watchRoom(roomCode) {
        roomListener = onValue(ref(db, `rooms/${roomCode}`), (snapshot) => {
            if (!snapshot.exists()) {
                alert("ë°©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
                backToLobby();
                return;
            }
            handleRoomUpdate(snapshot.val());
        });
        
        // ì±„íŒ… ë¦¬ìŠ¤ë„ˆ ì‹œì‘
        watchChat(roomCode);
    }
    
    // ==================== ì±„íŒ… ====================
    let lastChatCount = 0;  // ë§ˆì§€ë§‰ ì±„íŒ… ìˆ˜
    
    function watchChat(roomCode) {
        chatListener = onValue(ref(db, `rooms/${roomCode}/chat`), (snapshot) => {
            const messages = snapshot.val() || {};
            renderChatMessages(messages);
        });
    }
    
    function renderChatMessages(messages) {
        const container = document.getElementById('chat-messages');
        if (!container) return;
        
        // ë©”ì‹œì§€ë¥¼ ì‹œê°„ìˆœ ì •ë ¬
        const sorted = Object.entries(messages)
            .sort((a, b) => (a[1].timestamp || 0) - (b[1].timestamp || 0));
        
        // ìƒˆ ë©”ì‹œì§€ ì•Œë¦¼ (ë‚´ê°€ ë³´ë‚¸ ê²Œ ì•„ë‹Œ ê²½ìš°)
        if (sorted.length > lastChatCount && lastChatCount > 0) {
            const lastMsg = sorted[sorted.length - 1][1];
            const myId = isSpectator ? mySpectatorId : myPlayerId;
            
            if (lastMsg.senderId !== myId && lastMsg.type !== 'system') {
                playSound('chat');
                skipNextGameAnnounce = true;  // ê²Œì„ ì•Œë¦¼ ìŠ¤í‚µ
                announce(`${lastMsg.name}: ${lastMsg.text}`);
                setTimeout(() => { skipNextGameAnnounce = false; }, 1500);
            }
        }
        lastChatCount = sorted.length;
        
        // ëª©ë¡ êµ¬ì¡° ë Œë”ë§
        if (sorted.length === 0) {
            container.innerHTML = '<p style="color:#666; text-align:center; padding:20px;">ì±„íŒ… ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
            return;
        }
        
        const listItems = sorted.map(([id, msg]) => {
            const time = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' }) : '';
            const isSystem = msg.type === 'system';
            const isSpectatorMsg = msg.isSpectator;
            
            if (isSystem) {
                return `<li>${msg.text}</li>`;
            }
            
            const roleLabel = isSpectatorMsg ? ' ê´€ì „ì' : '';
            return `<li><strong>${msg.name}${roleLabel}</strong> (${time}): ${escapeHtml(msg.text)}</li>`;
        }).join('');
        
        container.innerHTML = `<ul class="chat-list">${listItems}</ul>`;
        
        // ìŠ¤í¬ë¡¤ ë§¨ ì•„ë˜ë¡œ
        container.scrollTop = container.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    async function sendChat() {
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        
        if (!text || !currentRoom) return;
        
        // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ ì½ê¸°
        skipNextGameAnnounce = true;
        announce(`ë‚˜: ${text}`);
        setTimeout(() => { skipNextGameAnnounce = false; }, 1500);
        
        input.value = '';
        input.focus();
        
        try {
            const newMsgRef = ref(db, `rooms/${currentRoom}/chat/${Date.now()}`);
            
            await set(newMsgRef, {
                name: myName,
                text: text,
                timestamp: Date.now(),
                isSpectator: isSpectator,
                senderId: isSpectator ? mySpectatorId : myPlayerId
            });
            
        } catch (error) {
            console.error("ì±„íŒ… ì „ì†¡ ì‹¤íŒ¨:", error);
        }
    }
    
    // ì±„íŒ… ì…ë ¥ì°½ Enter í‚¤ ì²˜ë¦¬
    document.addEventListener('DOMContentLoaded', () => {
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendChat();
                }
            });
        }
    });

    function handleRoomUpdate(data) {
        players = data.players || {};
        spectators = data.spectators || {};
        joinRequests = data.joinRequests || {};
        maxPlayers = data.maxPlayers;
        
        // AI ê²Œì„ ì—¬ë¶€ ì²´í¬
        if (data.isAIGame) {
            isAIGame = true;
        }
        
        // ê´€ì „ìê°€ í”Œë ˆì´ì–´ë¡œ ìŠ¹ê²©ëëŠ”ì§€ í™•ì¸
        if (isSpectator && mySpectatorId) {
            // ë‚´ ê´€ì „ì IDë¡œ ìŠ¹ê²©ëœ í”Œë ˆì´ì–´ê°€ ìˆëŠ”ì§€ í™•ì¸
            const promotedPlayer = Object.entries(players).find(
                ([id, p]) => p.promotedFrom === mySpectatorId
            );
            
            if (promotedPlayer) {
                // í”Œë ˆì´ì–´ë¡œ ì „í™˜!
                isSpectator = false;
                myPlayerId = promotedPlayer[0];
                mySpectatorId = null;
                
                // onDisconnect ì„¤ì •
                onDisconnect(ref(db, `rooms/${currentRoom}/players/${myPlayerId}/connected`)).set(false);
                
                announce(`ì¶•í•˜í•©ë‹ˆë‹¤! í”Œë ˆì´ì–´ë¡œ ì°¸ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì€ ${myPlayerId}ì…ë‹ˆë‹¤.`);
                alert(`ğŸ® í”Œë ˆì´ì–´ë¡œ ì°¸ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                
                // UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                document.getElementById('spectator-banner').style.display = 'none';
                document.getElementById('player-controls').style.display = 'block';
                document.getElementById('my-card-info').style.display = 'block';
            }
        }
        
        // ëŒ€ê¸° í™”ë©´ ì—…ë°ì´íŠ¸
        if (data.status === 'waiting') {
            updateWaitingScreen(data);
        }
        
        // ê²Œì„ ì§„í–‰ ì¤‘
        if (data.status === 'playing' && data.gameState) {
            // ê²Œì„ì´ ë§‰ ì‹œì‘ëì„ ë•Œ ì‚¬ìš´ë“œ ì¬ìƒ
            if (prevGameStatus === 'waiting') {
                playSound('gamestart');
            }
            showGameScreen();
            updateGameFromServer(data);
        }
        
        // ê²Œì„ ì¢…ë£Œ
        if (data.status === 'finished') {
            showResult(data);
        }
        
        // ìƒíƒœ ì €ì¥
        prevGameStatus = data.status;
    }

    function updateWaitingScreen(data) {
        const container = document.getElementById('players-container');
        const playerList = Object.entries(data.players || {});
        
        container.innerHTML = playerList.map(([id, p]) => {
            const isAI = p.isAI === true;
            const aiIcon = isAI ? 'ğŸ¤– ' : '';
            return `
                <div class="player-item ${id === myPlayerId ? 'me' : ''} ${isAI ? 'ai-player' : ''}">
                    <span>${aiIcon}${p.name} ${id === myPlayerId ? '(ë‚˜)' : ''}</span>
                    <span class="${p.connected ? 'player-ready' : 'player-waiting'}">
                        ${isAI ? 'AI' : (p.connected ? 'âœ“ ì¤€ë¹„' : 'ì—°ê²° ëŠê¹€')}
                    </span>
                </div>
            `;
        }).join('');
        
        document.getElementById('current-player-count').textContent = playerList.length;
        
        // AI ì¶”ê°€ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
        const aiSection = document.getElementById('ai-add-section');
        const isHost = myPlayerId === 'player1';
        const hasRoom = playerList.length < data.maxPlayers;
        
        if (aiSection) {
            aiSection.style.display = (isHost && hasRoom) ? 'block' : 'none';
        }
        
        // ê´€ì „ì ëª©ë¡ ì—…ë°ì´íŠ¸
        const specContainer = document.getElementById('spectators-container');
        const spectatorList = Object.entries(data.spectators || {});
        
        if (specContainer) {
            specContainer.innerHTML = spectatorList.map(([id, s]) => {
                const inviteBtn = (isHost && hasRoom && id !== mySpectatorId) 
                    ? `<button onclick="inviteSpectator('${id}', '${s.name}')" style="background:#2ecc71; padding:5px 10px; border:none; border-radius:5px; cursor:pointer; font-size:12px;">ì°¸ê°€ ì´ˆëŒ€</button>`
                    : '';
                
                return `
                    <div class="player-item ${id === mySpectatorId ? 'me' : ''}" style="border-color: #9b59b6;">
                        <span>ğŸ‘€ ${s.name} ${id === mySpectatorId ? '(ë‚˜)' : ''}</span>
                        <span style="color: #9b59b6;">
                            ${inviteBtn || 'ê´€ì „'}
                        </span>
                    </div>
                `;
            }).join('');
            
            document.getElementById('spectator-count').textContent = spectatorList.length;
        }
        
        const remaining = data.maxPlayers - playerList.length;
        document.getElementById('waiting-message').textContent = 
            remaining > 0 ? `ğŸ‘€ ${remaining}ëª… ë” í•„ìš”í•©ë‹ˆë‹¤...` : 'ğŸ® ê²Œì„ ì‹œì‘!';
    }

    // ==================== ê²Œì„ í™”ë©´ ====================
    function showGameScreen() {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        document.getElementById('game-room-code').textContent = currentRoom;
        document.getElementById('game-player-count').textContent = maxPlayers;
        
        // ê´€ì „ ëª¨ë“œ UI ì²˜ë¦¬
        if (isSpectator) {
            document.getElementById('spectator-banner').style.display = 'block';
            document.getElementById('player-controls').style.display = 'none';
            document.getElementById('my-card-info').style.display = 'none';
            announce('ê´€ì „ ëª¨ë“œë¡œ ê²½ê¸°ë¥¼ ê´€ëŒí•©ë‹ˆë‹¤.');
        } else {
            document.getElementById('spectator-banner').style.display = 'none';
            document.getElementById('player-controls').style.display = 'block';
            document.getElementById('my-card-info').style.display = 'block';
        }
    }

    function updateGameFromServer(data) {
        const gs = data.gameState;
        const isWaiting = data.status === 'waiting';
        const isPlaying = data.status === 'playing';
        
        // ê´€ì „ì ìˆ˜ ì—…ë°ì´íŠ¸
        const spectatorCount = Object.keys(data.spectators || {}).length;
        document.getElementById('game-spectator-count').textContent = spectatorCount;
        
        // ì°¸ê°€ ìš”ì²­ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ (ëŒ€ê¸° ì¤‘ì—ë§Œ í‘œì‹œ)
        const joinBtn = document.getElementById('btn-request-join');
        if (joinBtn) {
            joinBtn.style.display = isWaiting ? 'inline-block' : 'none';
        }
        
        // ì°¸ê°€ ìš”ì²­ ëª©ë¡ ì—…ë°ì´íŠ¸ (ë°©ì¥ì—ê²Œë§Œ, ëŒ€ê¸° ì¤‘ì—ë§Œ)
        const requestPanel = document.getElementById('join-requests-panel');
        const requestList = document.getElementById('join-requests-list');
        const requests = Object.entries(data.joinRequests || {});
        
        if (myPlayerId === 'player1' && requests.length > 0 && isWaiting) {
            requestPanel.style.display = 'block';
            requestList.innerHTML = requests.map(([id, r]) => `
                <div style="display:flex; justify-content:space-between; align-items:center; background:#1a1a2e; padding:10px; border-radius:5px; margin:5px 0;">
                    <span>ğŸ™‹ ${r.name}</span>
                    <div>
                        <button onclick="approveJoinRequest('${id}', '${r.name}')" style="background:#2ecc71; border:none; padding:5px 10px; border-radius:5px; cursor:pointer; margin-right:5px;">ìŠ¹ì¸</button>
                        <button onclick="rejectJoinRequest('${id}')" style="background:#95a5a6; border:none; padding:5px 10px; border-radius:5px; cursor:pointer;">ê±°ì ˆ</button>
                    </div>
                </div>
            `).join('');
        } else {
            requestPanel.style.display = 'none';
        }
        
        // ê´€ì „ì: ìš”ì²­ ìƒíƒœ ì—…ë°ì´íŠ¸
        if (isSpectator && mySpectatorId) {
            const myRequest = data.joinRequests?.[mySpectatorId];
            const btn = document.getElementById('btn-request-join');
            const status = document.getElementById('request-status');
            
            if (myRequest && isWaiting) {
                btn.disabled = true;
                status.style.display = 'inline';
                status.textContent = 'âœ“ ìš”ì²­ ì™„ë£Œ! ë°©ì¥ì˜ ìŠ¹ì¸ì„ ê¸°ë‹¤ë¦¬ì„¸ìš”.';
            } else if (isWaiting && !players[myPlayerId]) {
                // ìš”ì²­ì´ ì—†ê³  ì•„ì§ í”Œë ˆì´ì–´ê°€ ì•„ë‹ˆë©´ ë²„íŠ¼ í™œì„±í™”
                btn.disabled = false;
                status.style.display = 'none';
            } else if (isPlaying) {
                status.style.display = 'inline';
                status.textContent = 'ê²Œì„ ì§„í–‰ ì¤‘ì—ëŠ” ì°¸ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
            }
        }
        
        // ê´€ì „ìê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ë‚´ íŒ¨ ì²˜ë¦¬
        if (!isSpectator) {
            myHand = gs.hands?.[myPlayerId] || [];
        }
        
        // í„´ ì •ë³´
        const wasMyTurn = currentTurn === myPlayerId;
        currentTurn = gs.currentTurn;
        const isMyTurn = currentTurn === myPlayerId;
        
        // ë°”ë‹¥ íŒ¨
        const prevLastMove = lastMove;
        lastMove = gs.lastMove;
        
        // ë‚´ê°€ ë§ˆì¸í–ˆëŠ”ë° ë¦¬í„´ ì—†ì´ ë‚´ í„´ì´ ëŒì•„ì™”ìœ¼ë©´ â†’ ë§ˆì¸ ì„±ê³µ, ë°”ë‹¥ ë¹„ìš°ê¸°
        if (isMyTurn && gs.lastMove?.isMine && gs.lastMove?.mineBy === myPlayerId) {
            // ë¡œì»¬ ë³€ìˆ˜ ë¨¼ì € ì—…ë°ì´íŠ¸
            lastMove = null;
            
            // Firebase ì—…ë°ì´íŠ¸
            update(ref(db, `rooms/${currentRoom}/gameState`), {
                lastMove: null,
                lastMoveBy: null,
                passCount: 0
            });
            logMessage('ë§ˆì¸ ì„±ê³µ! ì„ ì„ ì¡ì•˜ìŠµë‹ˆë‹¤.');
            announce('ë§ˆì¸ ì„±ê³µ! ì¹´ë“œë¥¼ ë‚´ì„¸ìš”.');
            
            // UI ê°±ì‹ 
            updateAllInfo();
            renderHand();
        }
        
        // ì™„ì£¼ì ëª©ë¡
        finishedPlayers = gs.finishedOrder || [];
        
        // íƒ€ì¼ 3ê°œ ë‚¨ì•˜ì„ ë•Œ ì•Œë¦¼ (í”Œë ˆì´ì–´/ê´€ì „ì ëª¨ë‘)
        Object.entries(players).forEach(([id, p]) => {
            // ê´€ì „ìëŠ” ëª¨ë“  í”Œë ˆì´ì–´ ì²´í¬, í”Œë ˆì´ì–´ëŠ” ìƒëŒ€ë°©ë§Œ ì²´í¬
            if (isSpectator || id !== myPlayerId) {
                const currentCount = gs.hands?.[id]?.length || 0;
                const prevCount = prevOpponentHandCounts[id];
                
                // ì´ì „ì— 3ê°œ ì´ˆê³¼ì˜€ë‹¤ê°€ 3ê°œê°€ ëì„ ë•Œ ì•Œë¦¼
                if (prevCount !== undefined && prevCount > 3 && currentCount === 3) {
                    const playerName = p.name || id;
                    playSound('warning');
                    // alert ì œê±° (ê²Œì„ ë©ˆì¶¤ ë°©ì§€)
                }
                
                // í˜„ì¬ ê°œìˆ˜ ì €ì¥
                prevOpponentHandCounts[id] = currentCount;
            }
        });
        
        // í–‰ë™ ì•Œë¦¼ (ê´€ì „ìëŠ” ëª¨ë“  í–‰ë™, í”Œë ˆì´ì–´ëŠ” ìƒëŒ€ í–‰ë™ë§Œ)
        if (gs.lastMoveBy && gs.lastMove) {
            const shouldAnnounce = isSpectator || gs.lastMoveBy !== myPlayerId;
            
            if (shouldAnnounce && (!prevLastMove || prevLastMove.val !== gs.lastMove.val || prevLastMove.type !== gs.lastMove.type)) {
                const playerName = players[gs.lastMoveBy]?.name || gs.lastMoveBy;
                const moveDesc = getMoveDescription(gs.lastMove);
                
                // ìƒëŒ€ë°© ì¹´ë“œ ë‚¸ ì‚¬ìš´ë“œ
                playSound('opponent');
                
                // ê°„ëµí•œ ë©”ì‹œì§€ (ì±„íŒ… ì•Œë¦¼ ì¤‘ì´ë©´ ìŠ¤í‚µ)
                if (!skipNextGameAnnounce) {
                    announce(`${playerName}: ${moveDesc}`);
                }
                logMessage(`${playerName}: ${moveDesc}`);
                
                // ë§ˆì¸ ê°ì§€: moveDescì— "ë§ˆì¸"ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ë§ˆì¸
                if (moveDesc.includes('ë§ˆì¸') && gs.lastMoveBy !== myPlayerId) {
                    showReturnPanel(gs.lastMove.val, playerName);
                }
            }
        } else {
            // ë°”ë‹¥ì´ ë¹„ë©´ ë¦¬í„´ íŒ¨ë„ ìˆ¨ê¹€
            hideReturnPanel();
        }
        
        // íŒ¨ìŠ¤ ì•Œë¦¼ (ê´€ì „ìëŠ” ëª¨ë“  íŒ¨ìŠ¤, í”Œë ˆì´ì–´ëŠ” ìƒëŒ€ íŒ¨ìŠ¤ë§Œ)
        if (gs.passedBy && gs.passedBy !== prevPassedBy) {
            const shouldAnnouncePass = isSpectator || gs.passedBy !== myPlayerId;
            if (shouldAnnouncePass) {
                const playerName = players[gs.passedBy]?.name || gs.passedBy;
                if (!skipNextGameAnnounce) {
                    announce(`${playerName}: íŒ¨ìŠ¤`);
                }
                logMessage(`${playerName}: íŒ¨ìŠ¤`);
            }
        }
        prevPassedBy = gs.passedBy;
        
        // í„´ ë³€ê²½ ì‹œ ì‚¬ìš´ë“œì™€ ì•Œë¦¼
        if (!isSpectator && !wasMyTurn && isMyTurn && !gs.lastMove?.isMine) {
            playSound('myturn');
            announce('ë‚´ ì°¨ë¡€');
        }
        
        // UI ì—…ë°ì´íŠ¸
        renderOpponents(data);
        if (!isSpectator) {
            renderHand();
        }
        updateAllInfo();
        
        if (!isSpectator && isMyTurn && myHand.length > 0) {
            setTimeout(() => {
                const firstCard = document.querySelector('.card');
                if (firstCard) firstCard.focus();
            }, 100);
        }
        
        // ë§ˆì¸ í›„ ë§ˆì¸ í•œ ì‚¬ëŒì—ê²Œ í„´ ëŒì•„ì˜¤ë©´ ë°”ë‹¥ ë¹„ìš°ê¸° (ë°©ì¥ë§Œ ì²˜ë¦¬)
        if (myPlayerId === 'player1' && data.status === 'playing' && gs.lastMove?.isMine && gs.lastMove?.mineBy === gs.currentTurn) {
            // ë°”ë‹¥ ë¹„ìš°ê¸°
            update(ref(db, `rooms/${currentRoom}/gameState`), {
                lastMove: null,
                lastMoveBy: null
            });
            const mineName = players[gs.currentTurn]?.name || gs.currentTurn;
            logMessage(`${mineName}: ë§ˆì¸ ì„±ê³µ, ì„  ìœ ì§€`);
        }
        
        // AI í„´ ì²˜ë¦¬ (ë°©ì¥ë§Œ ì‹¤í–‰)
        if (isAIGame && myPlayerId === 'player1' && data.status === 'playing') {
            processAITurn(data);
        }
    }

    function renderOpponents(data) {
        const gs = data.gameState;
        const area = document.getElementById('opponents-area');
        const heading = document.getElementById('opponents-heading');
        
        // ê´€ì „ìëŠ” ëª¨ë“  í”Œë ˆì´ì–´ í‘œì‹œ, í”Œë ˆì´ì–´ëŠ” ìƒëŒ€ë°©ë§Œ í‘œì‹œ
        const playerList = Object.entries(players)
            .filter(([id]) => isSpectator || id !== myPlayerId);
        
        // í—¤ë”© í…ìŠ¤íŠ¸ ë³€ê²½
        if (heading) {
            heading.textContent = isSpectator ? 'í”Œë ˆì´ì–´ë“¤' : 'ë‹¤ë¥¸ í”Œë ˆì´ì–´';
        }
        
        const playerCards = playerList.map(([id, p]) => {
            const handCount = gs.hands?.[id]?.length || 0;
            const isCurrentTurn = gs.currentTurn === id;
            const isFinished = p.finished || handCount === 0;
            const isAI = p.isAI === true;
            
            // ê´€ì „ìëŠ” íŒ¨ ê°œìˆ˜ë„ ë³¼ ìˆ˜ ìˆìŒ
            const countDisplay = isSpectator 
                ? (isFinished ? `${p.rank}ë“± ì™„ì£¼!` : `íŒ¨ ${handCount}ì¥`)
                : (isFinished ? `${p.rank}ë“± ì™„ì£¼!` : 'ê²Œì„ ì¤‘');
            
            const aiLabel = isAI ? 'ğŸ¤– ' : '';
            const aiAriaLabel = isAI ? ' AI í”Œë ˆì´ì–´,' : '';
            
            return `
                <div class="opponent-card ${isCurrentTurn ? 'current-turn' : ''}" 
                     aria-label="${aiAriaLabel}${p.name}${isSpectator ? `, íŒ¨ ${handCount}ì¥` : ''}${isCurrentTurn ? ', í˜„ì¬ í„´' : ''}${isFinished ? ', ì™„ì£¼' : ''}">
                    <div class="opponent-name">${aiLabel}${p.name}${isFinished ? ' ğŸ†' : ''}</div>
                    <div class="opponent-count">
                        ${countDisplay}
                        ${isCurrentTurn ? ' â† í„´' : ''}
                    </div>
                </div>
            `;
        });
        
        area.innerHTML = playerCards.join('');
    }

    function renderHand() {
        const handDiv = document.getElementById('player-hand');
        
        // í˜„ì¬ í¬ì»¤ìŠ¤ê°€ ì¹´ë“œ ì˜ì—­ì— ìˆëŠ”ì§€ í™•ì¸
        const activeElement = document.activeElement;
        const wasInHand = activeElement && activeElement.classList.contains('card');
        const savedFocusIndex = wasInHand ? currentFocusIndex : -1;
        
        handDiv.innerHTML = '';
        
        // currentFocusIndexê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ì¡°ì •
        if (currentFocusIndex >= myHand.length) {
            currentFocusIndex = Math.max(0, myHand.length - 1);
        }
        
        myHand.forEach((num, idx) => {
            const card = document.createElement('div');
            const actualValue = getCardValue(num);
            const isRed = isRedOne(num);
            const isJoker = actualValue === 16;
            
            card.className = 'card' + (isJoker ? ' joker' : '') + (isRed ? ' red-one' : '');
            card.id = `card-${idx}`;
            card.setAttribute('tabindex', '0');
            
            const cardName = isJoker ? 'X' : (isRed ? 'ë¹¨ê°„ 1' : actualValue);
            const isSelected = selectedIndices.includes(idx);
            card.setAttribute('aria-label', `${cardName}${isSelected ? ', ì„ íƒë¨' : ''}`);
            card.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
            card.textContent = isJoker ? 'X' : actualValue;
            
            card.addEventListener('click', () => {
                if (currentTurn === myPlayerId) toggleCard(idx);
            });
            card.addEventListener('keydown', (e) => handleCardKeydown(e, idx));
            
            // í¬ì»¤ìŠ¤ ì‹œ ì¹´ë“œ ì •ë³´ ì•Œë¦¼
            card.addEventListener('focus', () => {
                currentFocusIndex = idx;
                if (!skipFocusAnnounce) {
                    const selected = selectedIndices.includes(idx);
                    announce(`${cardName}${selected ? ' ì„ íƒë¨' : ''}`);
                }
            });
            
            handDiv.appendChild(card);
        });
        
        // í¬ì»¤ìŠ¤ ë³µì› (ì¹´ë“œ ì˜ì—­ì— ìˆì—ˆê³ , ì¹´ë“œë¥¼ ë‚´ì§€ ì•Šì€ ê²½ìš°ë§Œ)
        if (savedFocusIndex >= 0 && myHand.length > 0 && !skipFocusRestore) {
            const newIdx = Math.min(savedFocusIndex, myHand.length - 1);
            const targetCard = document.getElementById(`card-${newIdx}`);
            if (targetCard) {
                skipFocusAnnounce = true;
                targetCard.focus();
                setTimeout(() => { skipFocusAnnounce = false; }, 50);
            }
        }
        skipFocusRestore = false;  // í”Œë˜ê·¸ ë¦¬ì…‹
        
        document.getElementById('hand-count').textContent = myHand.length;
        
        // 3ì¥ ë‚¨ìœ¼ë©´ 3ì¹´ë“œ ë²„íŠ¼ í‘œì‹œ
        const callBtn = document.getElementById('btn-call');
        if (callBtn) {
            callBtn.style.display = myHand.length === 3 ? 'inline-block' : 'none';
        }
        
        // ë§ˆì¸ ë²„íŠ¼ í‘œì‹œ (ë°”ë‹¥ì´ ì‹±ê¸€ì´ê³  ë‚´ íŒ¨ì— ê°™ì€ ìˆ«ì í˜ì–´ê°€ ìˆì„ ë•Œ)
        // ë§ˆì¸ì€ ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ˆì–´ë„ ê°€ëŠ¥
        const mineBtn = document.getElementById('btn-mine');
        if (mineBtn) {
            const wasVisible = mineBtn.style.display !== 'none';
            let canMine = false;
            if (lastMove && lastMove.type === 'SINGLE' && !lastMove.isMine) {
                const targetVal = lastMove.val;
                const matchCount = myHand.filter(card => getCardValue(card) === targetVal).length;
                canMine = matchCount >= 2;
            }
            mineBtn.style.display = canMine ? 'inline-block' : 'none';
            
            // ìƒˆë¡œ ë§ˆì¸ ê°€ëŠ¥í•´ì§€ë©´ ì•Œë¦¼
            if (canMine && !wasVisible) {
                const displayVal = lastMove.val === 16 ? 'X' : lastMove.val;
                announce(`${displayVal} ë§ˆì¸ ê°€ëŠ¥! Alt+M ë˜ëŠ” ë§ˆì¸ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.`);
            }
        }
    }

    // ==================== ì¹´ë“œ ì„ íƒ ====================
    let skipFocusAnnounce = false;  // focus ì´ë²¤íŠ¸ ì•Œë¦¼ ìŠ¤í‚µ í”Œë˜ê·¸
    
    function toggleCard(idx) {
        const card = document.getElementById(`card-${idx}`);
        if (!card) return;
        
        const num = myHand[idx];
        const actualValue = getCardValue(num);
        const isRed = isRedOne(num);
        const cardName = actualValue === 16 ? 'X' : (isRed ? 'ë¹¨ê°„ 1' : actualValue);
        
        if (selectedIndices.includes(idx)) {
            selectedIndices = selectedIndices.filter(i => i !== idx);
            card.setAttribute('aria-pressed', 'false');
            card.setAttribute('aria-label', `${cardName}`);
            announce(`${cardName} í•´ì œ`);
        } else {
            selectedIndices.push(idx);
            card.setAttribute('aria-pressed', 'true');
            card.setAttribute('aria-label', `${cardName}, ì„ íƒë¨`);
            announce(`${cardName} ì„ íƒ`);
        }
        
        // ì„ íƒ í›„ ì´ˆì  ìœ ì§€ (focus ì´ë²¤íŠ¸ ì•Œë¦¼ ìŠ¤í‚µ)
        skipFocusAnnounce = true;
        card.focus();
        setTimeout(() => { skipFocusAnnounce = false; }, 50);
        
        updateSelectionInfo();
    }

    function handleCardKeydown(e, idx) {
        const cards = document.querySelectorAll('.card');
        const cardCount = cards.length;
        
        // ALT ì¡°í•© ë‹¨ì¶•í‚¤
        if (e.altKey) {
            switch (e.key) {
                case 'p': case 'P': 
                    e.preventDefault(); 
                    playMove(); 
                    return;
                case 'x': case 'X': 
                    e.preventDefault(); 
                    passTurn(); 
                    return;
                case 'c': case 'C': 
                    e.preventDefault(); 
                    clearSelection(); 
                    return;
                case 's': case 'S': 
                    e.preventDefault(); 
                    announceStatus(); 
                    return;
                case 'r': case 'R':
                    e.preventDefault();
                    doReturn();
                    return;
            }
        }
        
        // ì¼ë°˜ í‚¤ (ë°©í–¥í‚¤, ìŠ¤í˜ì´ìŠ¤, ì—”í„°)
        switch (e.key) {
            case 'ArrowRight':
            case 'ArrowDown':
                e.preventDefault();
                moveFocusTo((idx + 1) % cardCount);
                break;
            case 'ArrowLeft':
            case 'ArrowUp':
                e.preventDefault();
                moveFocusTo((idx - 1 + cardCount) % cardCount);
                break;
            case ' ':
            case 'Enter':
                e.preventDefault();
                if (currentTurn === myPlayerId) toggleCard(idx);
                break;
            case 'Home':
                e.preventDefault();
                moveFocusTo(0);
                break;
            case 'End':
                e.preventDefault();
                moveFocusTo(cardCount - 1);
                break;
        }
    }

    function moveFocusTo(newIndex) {
        const cards = document.querySelectorAll('.card');
        if (cards.length === 0) return;
        
        currentFocusIndex = newIndex;
        cards[newIndex].focus();
    }

    // ==================== ì •ë³´ ì—…ë°ì´íŠ¸ ====================
    function updateAllInfo() {
        const isMyTurn = currentTurn === myPlayerId;
        document.getElementById('my-count').textContent = myHand.length;
        
        const turnDiv = document.getElementById('turn-status');
        const newTurnText = isMyTurn ? 'ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤!' : `${players[currentTurn]?.name || 'ìƒëŒ€ë°©'}ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤...`;
        // ë³€ê²½ ì‹œì—ë§Œ ì—…ë°ì´íŠ¸ (ìŠ¤í¬ë¦°ë¦¬ë” ì¤‘ë³µ ë°©ì§€)
        if (turnDiv.textContent !== newTurnText) {
            turnDiv.className = isMyTurn ? 'my-turn' : 'opponent-turn';
            turnDiv.textContent = newTurnText;
        }
        
        const tableDiv = document.getElementById('table-description');
        const newTableText = !lastMove ? 'ë°”ë‹¥ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.' : `ë°”ë‹¥: ${getMoveDescription(lastMove)}`;
        if (tableDiv.textContent !== newTableText) {
            tableDiv.textContent = newTableText;
        }
        
        document.getElementById('btn-play').disabled = !isMyTurn;
        document.getElementById('btn-pass').disabled = !isMyTurn;
        
        updateSelectionInfo();
    }

    function updateSelectionInfo() {
        const infoDiv = document.getElementById('selection-info');
        
        let newText;
        if (selectedIndices.length === 0) {
            newText = '';
        } else {
            const selectedCards = selectedIndices.map(i => myHand[i]).sort((a, b) => getCardValue(a) - getCardValue(b));
            const cardNames = selectedCards.map(n => {
                const val = getCardValue(n);
                if (val === 16) return 'X';
                if (isRedOne(n)) return 'ë¹¨ê°„1';
                return val;
            }).join(', ');
            const moveInfo = getMoveInfo(selectedCards);
            
            if (moveInfo) {
                newText = `${cardNames} â†’ ${getMoveDescription(moveInfo)}`;
            } else {
                newText = `${cardNames} â†’ ìœ íš¨í•˜ì§€ ì•ŠìŒ`;
            }
        }
        
        // ë³€ê²½ ì‹œì—ë§Œ ì—…ë°ì´íŠ¸
        if (infoDiv.textContent !== newText) {
            infoDiv.textContent = newText;
        }
    }

    async function announceStatus() {
        // Firebaseì—ì„œ ìµœì‹  ë°ì´í„° ì½ì–´ì˜¤ê¸°
        if (!currentRoom) {
            announce('ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return;
        }
        
        try {
            const snapshot = await get(ref(db, `rooms/${currentRoom}`));
            if (!snapshot.exists()) {
                announce('ë°© ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            const data = snapshot.val();
            const gs = data.gameState;
            const myHandCount = gs?.hands?.[myPlayerId]?.length || 0;
            const turn = gs?.currentTurn;
            const floor = gs?.lastMove;
            
            let msg = `ë‚´ íŒ¨ ${myHandCount}ì¥. `;
            msg += floor ? `ë°”ë‹¥: ${getMoveDescription(floor)}. ` : 'ë°”ë‹¥ ë¹„ì—ˆìŒ. ';
            msg += turn === myPlayerId ? 'ë‚´ ì°¨ë¡€.' : `${data.players[turn]?.name || 'ìƒëŒ€ë°©'} ì°¨ë¡€.`;
            announce(msg);
        } catch (error) {
            announce('ìƒíƒœë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
    }

    function clearSelection() {
        selectedIndices.forEach(idx => {
            const card = document.getElementById(`card-${idx}`);
            if (card) {
                card.setAttribute('aria-pressed', 'false');
                const num = myHand[idx];
                const actualValue = getCardValue(num);
                const cardName = actualValue === 16 ? 'X' : (isRedOne(num) ? 'ë¹¨ê°„ 1' : actualValue);
                card.setAttribute('aria-label', `${cardName}`);
            }
        });
        selectedIndices = [];
        updateSelectionInfo();
    }

    // ==================== ì¹´ë“œ íŒì • ====================
    // X(ì¡°ì»¤) ìë™ ëŒ€ì²´ í•¨ìˆ˜
    function autoReplaceJokers(cards) {
        const jokerIndices = [];
        const normalCards = [];
        
        cards.forEach((card, idx) => {
            if (getCardValue(card) === 16) {
                jokerIndices.push(idx);
            } else {
                normalCards.push(getCardValue(card));
            }
        });
        
        if (jokerIndices.length === 0) return cards;
        
        const jokerCount = jokerIndices.length;
        const sortedNormal = [...normalCards].sort((a, b) => a - b);
        
        // X ì‹±ê¸€ â†’ ê·¸ëƒ¥ X(16)ë¡œ ëƒ„
        if (cards.length === 1 && jokerCount === 1) {
            return [16];  // X ì‹±ê¸€
        }
        
        // Xë§Œìœ¼ë¡œ í˜ì–´(2ê°œ), ë°¤(3ê°œ), ë°¤íˆ¬(4ê°œ) â†’ ìˆ«ì ë¬¼ì–´ë³´ê¸°
        if (sortedNormal.length === 0 && jokerCount >= 2 && jokerCount <= 4) {
            let input = prompt('Xë¥¼ ì–´ë–¤ ìˆ«ìë¡œ? (1~15)', '1');
            if (input === null) return cards;  // ì·¨ì†Œì‹œ ì›ë³¸ ë°˜í™˜
            let targetVal = parseInt(input);
            if (isNaN(targetVal) || targetVal < 1 || targetVal > 15) targetVal = 1;
            const result = [...cards];
            jokerIndices.forEach(idx => result[idx] = targetVal);
            return result;
        }
        
        // 1ì¥ + X 1ì¥ â†’ í˜ì–´ë§Œ ê°€ëŠ¥ (ì¼ë°˜ì¹´ë“œ + Xë¡œ ë°¤/ë°¤íˆ¬ëŠ” ë¶ˆê°€)
        if (sortedNormal.length === 1 && jokerCount === 1) {
            const val = sortedNormal[0];
            const result = [...cards];
            jokerIndices.forEach(idx => result[idx] = val);
            return result;
        }
        
        // ìŠ¤íŠ¸ë ˆì´íŠ¸/í˜ì–´ìŠ¤íŠ¸ë ˆì´íŠ¸ (3ì¥ ì´ìƒ) â†’ ê° Xë§ˆë‹¤ ìˆ«ì ë¬¼ì–´ë³´ê¸°
        if (cards.length >= 3 && jokerCount > 0) {
            const result = [...cards];
            for (let i = 0; i < jokerCount; i++) {
                let input = prompt(`${i + 1}ë²ˆì§¸ Xë¥¼ ì–´ë–¤ ìˆ«ìë¡œ? (1~15, ë˜ëŠ” x)`, '1');
                if (input === null) return cards;  // ì·¨ì†Œì‹œ ì›ë³¸ ë°˜í™˜
                input = input.trim().toLowerCase();
                let targetVal;
                if (input === 'x') {
                    targetVal = 16;
                } else {
                    targetVal = parseInt(input);
                    if (isNaN(targetVal) || targetVal < 1 || targetVal > 16) targetVal = 1;
                }
                result[jokerIndices[i]] = targetVal;
            }
            return result;
        }
        
        // í˜ì–´ ì‹œë„ (2ì¥)
        if (cards.length === 2 && jokerCount === 1) {
            const result = [...cards];
            result[jokerIndices[0]] = sortedNormal[0];
            return result;
        }
        
        return cards;
    }

    function getMoveInfo(cards) {
        if (cards.length === 0) return null;
        
        // ì¹´ë“œ ê°’ì„ ì‹¤ì œ ê°’ìœ¼ë¡œ ë³€í™˜ (ë¹¨ê°„ 1 = 1)
        let sorted = [...cards].map(c => getCardValue(c)).sort((a, b) => a - b);
        let count = sorted.length;
        
        // ê°™ì€ ìˆ«ì ì „ë¶€
        if (sorted.every(c => c === sorted[0])) {
            if (count === 4) return { type: 'BOMB_TWO', val: sorted[0], cnt: 4 };  // 4ì¥ = BOMB TWO
            if (count === 3) return { type: 'BOMB', val: sorted[0], cnt: 3 };       // 3ì¥ = BOMB
            if (count === 2) return { type: 'PAIR', val: sorted[0], cnt: 2 };
            if (count === 1) return { type: 'SINGLE', val: sorted[0], cnt: 1 };
        }
        
        // ì¼ë°˜ ìŠ¤íŠ¸ë ˆì´íŠ¸ (ì—°ì†ëœ ìˆ«ì 1ì¥ì”©)
        let isStr = true;
        for (let i = 0; i < count - 1; i++) {
            if (sorted[i] + 1 !== sorted[i + 1]) isStr = false;
        }
        if (isStr && count >= 3) return { type: 'STRAIGHT', val: sorted[0], cnt: count };
        
        // í˜ì–´ ìŠ¤íŠ¸ë ˆì´íŠ¸ (ì—°ì†ëœ ìˆ«ì 2ì¥ì”©, ì˜ˆ: 3,3,4,4,5,5)
        if (count >= 6 && count % 2 === 0) {
            let isPairStr = true;
            const pairCount = count / 2;
            
            for (let i = 0; i < pairCount; i++) {
                const idx = i * 2;
                // ê°™ì€ ìˆ«ì 2ê°œì”©ì¸ì§€ í™•ì¸
                if (sorted[idx] !== sorted[idx + 1]) {
                    isPairStr = false;
                    break;
                }
                // ë‹¤ìŒ í˜ì–´ì™€ ì—°ì†ì¸ì§€ í™•ì¸
                if (i < pairCount - 1 && sorted[idx] + 1 !== sorted[idx + 2]) {
                    isPairStr = false;
                    break;
                }
            }
            
            if (isPairStr) {
                return { type: 'PAIR_STRAIGHT', val: sorted[0], cnt: count, pairCount: pairCount };
            }
        }
        
        return null;
    }

    function canBeat(newMove) {
        if (!lastMove) return true;
        
        // BOMB_TWO(4ì¥)ê°€ ìµœê°•
        if (newMove.type === 'BOMB_TWO') {
            if (lastMove.type !== 'BOMB_TWO') return true;
            return newMove.val > lastMove.val;
        }
        
        // BOMB(3ì¥)ì€ BOMB_TWO ë¹¼ê³  ë‹¤ ì´ê¹€
        if (newMove.type === 'BOMB') {
            if (lastMove.type === 'BOMB_TWO') return false;
            if (lastMove.type !== 'BOMB') return true;
            return newMove.val > lastMove.val;
        }
        
        if (newMove.type === lastMove.type && newMove.cnt === lastMove.cnt) {
            return newMove.val > lastMove.val;
        }
        
        return false;
    }

    function getMoveDescription(move) {
        if (!move) return '';
        
        // 16ì€ Xë¡œ í‘œì‹œ, jokerValsì— ìˆëŠ” ê°’ì€ ë’¤ì— x ì¶”ê°€
        const jokerVals = move.jokerVals || [];
        const displayVal = (val) => {
            if (val === 16) return 'X';
            if (jokerVals.includes(val)) return `${val}x`;
            return val;
        };
        
        // ë§ˆì¸/ë¦¬í„´ì€ ë³„ë„ í˜•ì‹
        if (move.isMine) {
            return `${displayVal(move.val)}ë§ˆì¸`;
        }
        if (move.isReturn) {
            return `${displayVal(move.val)}ë¦¬í„´`;
        }
        
        switch (move.type) {
            case 'SINGLE':
                return `${displayVal(move.val)} ì‹±ê¸€`;
            case 'PAIR':
                // í˜ì–´ì—ì„œ X ì‚¬ìš©ì‹œ í‘œì‹œ
                if (jokerVals.length > 0) {
                    return `${move.val}x í˜ì–´`;
                }
                return `${displayVal(move.val)} í˜ì–´`;
            case 'STRAIGHT':
                // ì‹œì‘ê°’ë¶€í„° cntê°œì˜ ì—°ì† ìˆ«ì
                const values = [];
                for (let i = 0; i < move.cnt; i++) {
                    const v = move.val + i;
                    values.push(jokerVals.includes(v) ? `${v}x` : (v === 16 ? 'X' : v));
                }
                return `${values.join(', ')} ìŠ¤íŠ¸ë ˆì´íŠ¸`;
            case 'PAIR_STRAIGHT':
                // í˜ì–´ ìŠ¤íŠ¸ë ˆì´íŠ¸ (ì˜ˆ: 3,4,5 í˜ì–´ìŠ¤íŠ¸ë ˆì´íŠ¸)
                const pairValues = [];
                for (let i = 0; i < move.pairCount; i++) {
                    const v = move.val + i;
                    // í˜ì–´ìŠ¤íŠ¸ë ˆì´íŠ¸ì—ì„œ í•´ë‹¹ ê°’ì´ jokerValsì— ìˆìœ¼ë©´ x í‘œì‹œ
                    const jokerCountForVal = jokerVals.filter(jv => jv === v).length;
                    if (jokerCountForVal > 0) {
                        pairValues.push(`${v}x`);
                    } else {
                        pairValues.push(v === 16 ? 'X' : v);
                    }
                }
                return `${pairValues.join(', ')} í˜ì–´ìŠ¤íŠ¸ë ˆì´íŠ¸`;
            case 'BOMB':
                if (jokerVals.length > 0) {
                    return `${move.val}xë°¤`;
                }
                return `${displayVal(move.val)}ë°¤`;
            case 'BOMB_TWO':
                if (jokerVals.length > 0) {
                    return `${move.val}xë°¤íˆ¬`;
                }
                return `${displayVal(move.val)}ë°¤íˆ¬`;
            default:
                return move.type;
        }
    }

    // ==================== ë‹¤ìŒ í„´ ê³„ì‚° ====================
    function getNextTurn(currentTurnId, skipFinished = true) {
        const playerIds = [];
        for (let i = 1; i <= maxPlayers; i++) {
            playerIds.push(`player${i}`);
        }
        
        let currentIdx = playerIds.indexOf(currentTurnId);
        let nextIdx = (currentIdx + 1) % playerIds.length;
        let attempts = 0;
        
        while (attempts < playerIds.length) {
            const nextId = playerIds[nextIdx];
            const player = players[nextId];
            
            // ì™„ì£¼í•˜ì§€ ì•Šì€ í”Œë ˆì´ì–´ ì°¾ê¸°
            if (!player?.finished && player?.connected) {
                return nextId;
            }
            
            nextIdx = (nextIdx + 1) % playerIds.length;
            attempts++;
        }
        
        return null;  // ëª¨ë‘ ì™„ì£¼
    }

    // ==================== ì¹´ë“œ ë‚´ê¸° ====================
    async function playMove() {
        if (isProcessing) {
            console.log('playMove: isProcessing is true');
            return;
        }
        
        if (currentTurn !== myPlayerId) {
            console.log('playMove: not my turn', currentTurn, myPlayerId);
            return;  // ë‚´ ì°¨ë¡€ ì•„ë‹ˆë©´ ì¡°ìš©íˆ ë¬´ì‹œ
        }
        
        if (selectedIndices.length === 0) {
            announce('ì¹´ë“œë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.');
            return;
        }
        
        isProcessing = true;
        
        try {
            const originalCards = selectedIndices.map(idx => myHand[idx]);
            console.log('playMove: originalCards', originalCards);
            
            // X(ì¡°ì»¤) ìë™ ëŒ€ì²´
            let cards = autoReplaceJokers([...originalCards]);
            console.log('playMove: cards after joker replace', cards);
            
            // ì‚¬ìš©ìê°€ ì·¨ì†Œí•œ ê²½ìš° (ì›ë³¸ê³¼ ë™ì¼í•˜ê³  ì¡°ì»¤ í¬í•¨)
            if (cards === originalCards && originalCards.some(c => getCardValue(c) === 16)) {
                announce('ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                return;
            }
            
            // Xê°€ ëŒ€ì²´ëœ ê°’ ì¶”ì 
            const jokerVals = [];
            originalCards.forEach((orig, idx) => {
                if (getCardValue(orig) === 16 && getCardValue(cards[idx]) !== 16) {
                    jokerVals.push(getCardValue(cards[idx]));
                }
            });
            
            const move = getMoveInfo(cards);
            console.log('playMove: move', move);
            
            if (!move) {
                announce('ìœ íš¨í•˜ì§€ ì•Šì€ ì¡°í•©ì…ë‹ˆë‹¤.');
                return;
            }
            
            // X ì‚¬ìš© ì •ë³´ ì €ì¥
            if (jokerVals.length > 0) {
                move.jokerVals = jokerVals;
            }
            
            // ë§ˆì¸ ì²´í¬: ì‹±ê¸€ ë°”ë‹¥ì— ê°™ì€ ìˆ«ì í˜ì–´ â†’ í„´ ë„˜ê¹€ (ë¦¬í„´ ê¸°íšŒ ì¤Œ)
            if (lastMove && lastMove.type === 'SINGLE' && move.type === 'PAIR' && move.val === lastMove.val) {
                announce(`${move.val}ë§ˆì¸!`);
                logMessage(`ë‚˜: ${move.val}ë§ˆì¸`);
                move.isMine = true;
                move.mineBy = myPlayerId;
                await submitMove(move, false);
                return;
            }
            
            // ë¦¬í„´ ì²´í¬: ë§ˆì¸ í˜ì–´ ë°”ë‹¥ì— ê°™ì€ ìˆ«ì ì‹±ê¸€ â†’ ì„  ê°€ì ¸ì˜´
            if (lastMove && lastMove.isMine && lastMove.type === 'PAIR' && move.type === 'SINGLE' && move.val === lastMove.val) {
                announce(`${move.val}ë¦¬í„´!`);
                logMessage(`ë‚˜: ${move.val}ë¦¬í„´`);
                move.isReturn = true;
                await submitMove(move, true);
                return;
            }
            
            console.log('playMove: canBeat?', canBeat(move), 'lastMove:', lastMove);
            
            if (canBeat(move)) {
                announce(`ë‚˜: ${getMoveDescription(move)}`);
                logMessage(`ë‚˜: ${getMoveDescription(move)}`);
                await submitMove(move, false);
            } else {
                announce('ë°”ë‹¥ì„ ì´ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        } finally {
            isProcessing = false;
        }
    }

    async function submitMove(move, keepTurn) {
        const newHand = myHand.filter((_, i) => !selectedIndices.includes(i));
        selectedIndices = [];
        
        // ì¹´ë“œ ë‚¸ í›„ì—ëŠ” í¬ì»¤ìŠ¤ ë³µì› ì•ˆ í•¨
        skipFocusRestore = true;
        
        const updates = {
            [`gameState/hands/${myPlayerId}`]: newHand,
            'gameState/lastMove': move,
            'gameState/lastMoveBy': myPlayerId,
            'gameState/passCount': 0  // ì¹´ë“œ ë‚´ë©´ íŒ¨ìŠ¤ ì¹´ìš´íŠ¸ ë¦¬ì…‹
        };
        
        // ì™„ì£¼ ì²´í¬ - ëˆ„êµ°ê°€ íŒ¨ë¥¼ ë‹¤ ë‚´ë©´ ë°”ë¡œ ê²Œì„ ì¢…ë£Œ
        if (newHand.length === 0) {
            const currentFinished = finishedPlayers.length;
            const myRank = currentFinished + 1;
            
            updates[`players/${myPlayerId}/finished`] = true;
            updates[`players/${myPlayerId}/rank`] = myRank;
            updates['gameState/finishedOrder'] = [...finishedPlayers, myPlayerId];
            updates['status'] = 'finished';  // ë°”ë¡œ ê²Œì„ ì¢…ë£Œ
        } else {
            // ë‹¤ìŒ í„´
            updates['gameState/currentTurn'] = keepTurn ? myPlayerId : getNextTurn(myPlayerId);
        }
        
        await update(ref(db, `rooms/${currentRoom}`), updates);
        
        // ì‚¬ìš´ë“œ ì¬ìƒ
        playSound('play');
        
        // 3ì¥ ë‚¨ìœ¼ë©´ ê²½ê³ ìŒ
        if (newHand.length === 3) {
            setTimeout(() => playSound('warning'), 300);
            announce('ì£¼ì˜! ì¹´ë“œê°€ 3ì¥ ë‚¨ì•˜ìŠµë‹ˆë‹¤!');
        }
    }

    // ==================== íŒ¨ìŠ¤ ====================
    async function passTurn() {
        if (isProcessing) return;
        
        if (currentTurn !== myPlayerId) {
            return;  // ë‚´ ì°¨ë¡€ ì•„ë‹ˆë©´ ì¡°ìš©íˆ ë¬´ì‹œ
        }
        
        isProcessing = true;
        
        try {
            announce('ë‚˜: íŒ¨ìŠ¤');
            logMessage('ë‚˜: íŒ¨ìŠ¤');
            
            // Firebaseì—ì„œ í˜„ì¬ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
            const snapshot = await get(ref(db, `rooms/${currentRoom}`));
            const data = snapshot.val();
            const gs = data.gameState;
            const nextTurn = getNextTurn(myPlayerId);
            
            // ë§ˆì¸ ìƒíƒœì—ì„œëŠ” ë‹¨ìˆœíˆ ë‹¤ìŒ í„´ìœ¼ë¡œ ë„˜ê¹€
            if (gs.lastMove?.isMine) {
                await update(ref(db, `rooms/${currentRoom}/gameState`), {
                    currentTurn: nextTurn,
                    passedBy: myPlayerId
                });
                clearSelection();
                return;
            }
            
            // í™œì„± í”Œë ˆì´ì–´ ìˆ˜ (ì™„ì£¼í•˜ì§€ ì•Šì€ í”Œë ˆì´ì–´)
            const activePlayers = Object.entries(data.players)
                .filter(([id, p]) => !p.finished)
                .length;
            
            const currentPassCount = (gs.passCount || 0) + 1;
            
            // ëª¨ë‘ íŒ¨ìŠ¤í–ˆìœ¼ë©´ (í™œì„± í”Œë ˆì´ì–´ - 1ëª… ëª¨ë‘ íŒ¨ìŠ¤) â†’ ì„ ì„ ì¡ìŒ
            if (currentPassCount >= activePlayers - 1 && gs.lastMoveBy) {
                await update(ref(db, `rooms/${currentRoom}/gameState`), {
                    currentTurn: gs.lastMoveBy,
                    lastMove: null,
                    lastMoveBy: null,
                    passCount: 0,
                    passedBy: myPlayerId
                });
                logMessage(`${data.players[gs.lastMoveBy]?.name || gs.lastMoveBy}: ì„ ì„ ì¡ìŒ`);
            } else {
                // ì¼ë°˜ íŒ¨ìŠ¤
                await update(ref(db, `rooms/${currentRoom}/gameState`), {
                    currentTurn: nextTurn,
                    passCount: currentPassCount,
                    passedBy: myPlayerId
                });
            }
            
            clearSelection();
        } finally {
            isProcessing = false;
        }
    }
    
    // 3ì¹´ë“œ ì•Œë¦¼
    async function callCards() {
        if (myHand.length !== 3) return;
        
        const myName = players[myPlayerId]?.name || 'ë‚˜';
        showToast(`ğŸ“¢ ${myName}: 3ì¹´ë“œ!`, 'warning');
        announce(`${myName}: 3ì¹´ë“œ!`);
        logMessage(`${myName}: 3ì¹´ë“œ!`);
        playSound('warning');
        
        // ë²„íŠ¼ ìˆ¨ê¸°ê¸° (í•œ ë²ˆë§Œ ì•Œë¦¼)
        const callBtn = document.getElementById('btn-call');
        if (callBtn) callBtn.style.display = 'none';
    }

    // ==================== ë§ˆì¸/ë¦¬í„´ ì²˜ë¦¬ ====================
    
    // ìë™ ë§ˆì¸ (Alt+M) - ë§ˆì¸ì€ ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ˆì–´ë„ ê°€ëŠ¥
    async function autoMine() {
        // ë°”ë‹¥ì´ ì‹±ê¸€ì¸ì§€ í™•ì¸
        if (!lastMove || lastMove.type !== 'SINGLE') {
            announce('ë§ˆì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°”ë‹¥ì´ ì‹±ê¸€ì´ ì•„ë‹™ë‹ˆë‹¤.');
            return;
        }
        
        // ì´ë¯¸ ë§ˆì¸ ìƒíƒœë©´ ë¶ˆê°€
        if (lastMove.isMine) {
            announce('ì´ë¯¸ ë§ˆì¸ ìƒíƒœì…ë‹ˆë‹¤.');
            return;
        }
        
        const targetVal = lastMove.val;
        
        // ë‚´ íŒ¨ì—ì„œ ê°™ì€ ìˆ«ì 2ì¥ ì°¾ê¸°
        const matchingIndices = [];
        myHand.forEach((card, idx) => {
            if (getCardValue(card) === targetVal) {
                matchingIndices.push(idx);
            }
        });
        
        if (matchingIndices.length < 2) {
            announce(`ë§ˆì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ${targetVal} í˜ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.`);
            return;
        }
        
        // 2ì¥ ì„ íƒí•´ì„œ ë§ˆì¸
        const mineIndices = matchingIndices.slice(0, 2);
        const cards = mineIndices.map(idx => myHand[idx]);
        const move = getMoveInfo(cards);
        
        if (move && move.type === 'PAIR' && move.val === targetVal) {
            // ë§ˆì¸ ì²˜ë¦¬ (ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì§ì ‘ ì—…ë°ì´íŠ¸)
            move.isMine = true;
            move.mineBy = myPlayerId;
            
            const newHand = myHand.filter((_, i) => !mineIndices.includes(i));
            
            // ë‹¤ìŒ í„´ ê³„ì‚° (ë§ˆì¸í•œ ì‚¬ëŒ ë‹¤ìŒë¶€í„°)
            const nextTurn = getNextTurn(myPlayerId);
            
            const updates = {
                [`gameState/hands/${myPlayerId}`]: newHand,
                'gameState/lastMove': move,
                'gameState/lastMoveBy': myPlayerId,
                'gameState/passCount': 0,
                'gameState/currentTurn': nextTurn  // ë‹¤ìŒ ì‚¬ëŒë¶€í„° ë¦¬í„´ ê¸°íšŒ
            };
            
            // ì™„ì£¼ ì²´í¬
            if (newHand.length === 0) {
                updates[`players/${myPlayerId}/finished`] = true;
                updates[`players/${myPlayerId}/rank`] = finishedPlayers.length + 1;
                updates['gameState/finishedOrder'] = [...finishedPlayers, myPlayerId];
                updates['status'] = 'finished';
            }
            
            await update(ref(db, `rooms/${currentRoom}`), updates);
            
            const displayVal = targetVal === 16 ? 'X' : targetVal;
            announce(`${displayVal}ë§ˆì¸!`);
            logMessage(`ë‚˜: ${displayVal}ë§ˆì¸`);
            playSound('play');
        }
    }
    
    function showReturnPanel(mineVal, mineByName) {
        // ë‚´ íŒ¨ì— í•´ë‹¹ ìˆ«ìê°€ ìˆëŠ”ì§€ í™•ì¸
        const hasReturnCard = myHand.some(card => getCardValue(card) === mineVal);
        
        const panel = document.getElementById('return-panel');
        const message = document.getElementById('return-message');
        const btn = document.getElementById('btn-return');
        const timer = document.getElementById('return-timer');
        
        if (!hasReturnCard || isSpectator) {
            panel.style.display = 'none';
            return;
        }
        
        const displayVal = mineVal === 16 ? 'X' : mineVal;
        message.textContent = `${mineByName}ì˜ ${displayVal}ë§ˆì¸! ë¦¬í„´í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        btn.disabled = false;
        panel.style.display = 'block';
        
        // ì•Œë¦¼ + í¬ì»¤ìŠ¤ë¥¼ ë¦¬í„´ ë²„íŠ¼ìœ¼ë¡œ
        announce(`${mineByName}ì˜ ${displayVal}ë§ˆì¸! ë¦¬í„´ ê°€ëŠ¥! Alt+R ë˜ëŠ” ë¦¬í„´ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.`);
        setTimeout(() => btn.focus(), 100);
        
        // íƒ€ì´ë¨¸ ì‹œì‘
        let remaining = RETURN_WAIT_TIME;
        timer.textContent = `ë‚¨ì€ ì‹œê°„: ${remaining}ì´ˆ`;
        
        if (mineState?.timer) {
            clearInterval(mineState.timer);
        }
        
        const timerInterval = setInterval(() => {
            remaining--;
            timer.textContent = `ë‚¨ì€ ì‹œê°„: ${remaining}ì´ˆ`;
            
            if (remaining <= 0) {
                clearInterval(timerInterval);
                hideReturnPanel();
            }
        }, 1000);
        
        mineState = { val: mineVal, timer: timerInterval };
    }
    
    function hideReturnPanel() {
        const panel = document.getElementById('return-panel');
        if (panel) panel.style.display = 'none';
        
        if (mineState?.timer) {
            clearInterval(mineState.timer);
        }
        mineState = null;
    }
    
    async function doReturn() {
        // íŒ¨ë„ ë¨¼ì € ìˆ¨ê¹€
        const panel = document.getElementById('return-panel');
        if (panel) panel.style.display = 'none';
        
        if (!mineState) {
            return;
        }
        
        const returnVal = mineState.val;
        
        // íƒ€ì´ë¨¸ ì •ë¦¬
        if (mineState.timer) {
            clearInterval(mineState.timer);
        }
        mineState = null;
        
        // í•´ë‹¹ ìˆ«ì ì¹´ë“œ ì°¾ê¸°
        const returnCardIndex = myHand.findIndex(card => getCardValue(card) === returnVal);
        if (returnCardIndex === -1) {
            return;
        }
        
        const newHand = myHand.filter((_, i) => i !== returnCardIndex);
        
        announce(`ë‚˜: ${returnVal}ë¦¬í„´`);
        logMessage(`ë‚˜: ${returnVal}ë¦¬í„´`);
        
        try {
            const updates = {
                [`gameState/hands/${myPlayerId}`]: newHand,
                'gameState/lastMove': null,
                'gameState/lastMoveBy': myPlayerId,
                'gameState/passCount': 0,
                'gameState/currentTurn': myPlayerId
            };
            
            // ì™„ì£¼ ì²´í¬ - ëˆ„êµ°ê°€ íŒ¨ë¥¼ ë‹¤ ë‚´ë©´ ë°”ë¡œ ê²Œì„ ì¢…ë£Œ
            if (newHand.length === 0) {
                const currentFinished = finishedPlayers.length;
                const myRank = currentFinished + 1;
                
                updates[`players/${myPlayerId}/finished`] = true;
                updates[`players/${myPlayerId}/rank`] = myRank;
                updates['gameState/finishedOrder'] = [...finishedPlayers, myPlayerId];
                updates['status'] = 'finished';  // ë°”ë¡œ ê²Œì„ ì¢…ë£Œ
            }
            
            await update(ref(db, `rooms/${currentRoom}`), updates);
            playSound('play');
        } catch (error) {
            console.error("ë¦¬í„´ ì‹¤íŒ¨:", error);
        }
    }

    // ==================== ê²°ê³¼ í‘œì‹œ ====================
    function showResult(data) {
        const modal = document.getElementById('result-modal');
        const title = document.getElementById('result-title');
        const rankings = document.getElementById('rankings');
        const msg = document.getElementById('result-message');
        
        // ê²Œì„ ì¢…ë£Œ ì‚¬ìš´ë“œ
        playSound('gameover');
        
        // ê²Œì„ í™”ë©´ ì™„ì „íˆ ìˆ¨ê¸°ê¸° (ìŠ¤í¬ë¦°ë¦¬ë”ì—ì„œë„ íƒìƒ‰ ì•ˆ ë¨)
        document.getElementById('game-container').style.display = 'none';
        
        const gs = data.gameState;
        
        // ìˆœìœ„ ì •ë ¬
        const sortedPlayers = Object.entries(data.players)
            .map(([id, p]) => ({ 
                id, 
                ...p,
                remainingCards: gs?.hands?.[id]?.length || 0  // ë‚¨ì€ íƒ€ì¼ ê°œìˆ˜
            }))
            .sort((a, b) => {
                if (a.rank && b.rank) return a.rank - b.rank;
                if (a.rank) return -1;
                if (b.rank) return 1;
                // ìˆœìœ„ê°€ ì—†ìœ¼ë©´ ë‚¨ì€ ì¹´ë“œ ìˆ˜ë¡œ ì •ë ¬ (ì ì€ ê²Œ ë†’ì€ ìˆœìœ„)
                return a.remainingCards - b.remainingCards;
            });
        
        // ìŠ¤í¬ë¦° ë¦¬ë”ìš© ê²°ê³¼ í…ìŠ¤íŠ¸
        const resultLines = ['ê²½ê¸° ì¢…ë£Œ.'];
        sortedPlayers.forEach((p, idx) => {
            const rank = p.rank || (idx + 1);
            const isMe = p.id === myPlayerId;
            const remainingText = p.remainingCards > 0 ? `ë‚¨ì€ íƒ€ì¼ ${p.remainingCards}ì¥` : 'ì™„ì£¼';
            resultLines.push(`${rank}ë“± ${p.name}${isMe ? ' ë‚˜' : ''}, ${remainingText}.`);
        });
        
        // ìˆœìœ„ í‘œì‹œ (ë‚¨ì€ íƒ€ì¼ ê°œìˆ˜ í¬í•¨)
        rankings.innerHTML = sortedPlayers.map((p, idx) => {
            const rank = p.rank || (idx + 1);
            const rankClass = rank <= 3 ? `rank-${rank}` : '';
            const isMe = p.id === myPlayerId;
            const remainingText = p.remainingCards > 0 ? `(ë‚¨ì€ íƒ€ì¼: ${p.remainingCards}ì¥)` : '(ì™„ì£¼!)';
            
            return `
                <div class="rank-item" ${isMe ? 'style="border: 2px solid #e94560;"' : ''}>
                    <span class="rank-number ${rankClass}">${rank}ë“±</span>
                    <span>${p.name}${isMe ? ' (ë‚˜)' : ''} ${remainingText}</span>
                </div>
            `;
        }).join('');
        
        const myRank = data.players[myPlayerId]?.rank || (sortedPlayers.findIndex(p => p.id === myPlayerId) + 1);
        
        if (isSpectator) {
            title.className = '';
            title.textContent = 'ğŸ ê²½ê¸° ì¢…ë£Œ';
        } else if (myRank === 1) {
            title.className = 'win';
            title.textContent = 'ğŸ‰ 1ë“±! ìŠ¹ë¦¬!';
            resultLines.unshift('ì¶•í•˜í•©ë‹ˆë‹¤! 1ë“±ìœ¼ë¡œ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!');
        } else {
            title.className = 'lose';
            title.textContent = `${myRank}ë“±`;
        }
        
        // ê²°ê³¼ë§Œ ì•Œë¦¼
        announce(resultLines.join(' '));
        
        msg.textContent = '';
        modal.style.display = 'flex';
        
        // ê²°ê³¼ ëª¨ë‹¬ì— ì´ˆì 
        setTimeout(() => {
            const closeBtn = modal.querySelector('button');
            if (closeBtn) closeBtn.focus();
        }, 100);
    }

    // ==================== ê²Œì„ ê´€ë¦¬ ====================
    async function cancelRoom() {
        if (currentRoom) {
            try { await remove(ref(db, `rooms/${currentRoom}`)); } catch (e) {}
        }
        if (roomListener) roomListener();
        backToLobby();
    }

    async function leaveGame() {
        if (currentRoom) {
            try {
                if (isSpectator && mySpectatorId) {
                    // ê´€ì „ìì¸ ê²½ìš° ê´€ì „ì ëª©ë¡ì—ì„œ ì‚­ì œ
                    await remove(ref(db, `rooms/${currentRoom}/spectators/${mySpectatorId}`));
                } else if (myPlayerId) {
                    // í”Œë ˆì´ì–´ì¸ ê²½ìš° ì—°ê²° í•´ì œ
                    await update(ref(db, `rooms/${currentRoom}/players/${myPlayerId}`), {
                        connected: false
                    });
                }
            } catch (e) {}
        }
        backToLobby();
    }

    function backToLobby() {
        if (roomListener) roomListener();
        if (chatListener) chatListener();
        hideReturnPanel();
        currentRoom = null;
        myPlayerId = null;
        myHand = [];
        selectedIndices = [];
        lastMove = null;
        players = {};
        spectators = {};
        finishedPlayers = [];
        isSpectator = false;
        mySpectatorId = null;
        prevOpponentHandCounts = {};
        prevPassedBy = null;
        joinRequests = {};
        lastChatCount = 0;
        prevGameStatus = null;
        isAIGame = false;
        aiThinking = false;
        skipNextGameAnnounce = false;
        isProcessing = false;
        skipFocusRestore = false;
        mineState = null;
        
        document.getElementById('result-modal').style.display = 'none';
        document.getElementById('game-container').style.display = 'none';
        document.getElementById('lobby').style.display = 'block';
        document.getElementById('lobby-main').style.display = 'block';
        document.getElementById('lobby-waiting').style.display = 'none';
        document.getElementById('log').innerHTML = '';
        document.getElementById('chat-messages').innerHTML = '';
    }

    // ==================== ê´€ì „ì ì°¸ê°€ ìš”ì²­ ====================
    async function requestJoinGame() {
        if (!isSpectator || !mySpectatorId || !currentRoom) return;
        
        const btn = document.getElementById('btn-request-join');
        const status = document.getElementById('request-status');
        
        btn.disabled = true;
        status.style.display = 'inline';
        status.textContent = 'ìš”ì²­ ì¤‘...';
        
        try {
            // ì°¸ê°€ ìš”ì²­ ì €ì¥
            await update(ref(db, `rooms/${currentRoom}/joinRequests`), {
                [mySpectatorId]: {
                    name: myName,
                    spectatorId: mySpectatorId,
                    requestedAt: serverTimestamp()
                }
            });
            
            status.textContent = 'âœ“ ìš”ì²­ ì™„ë£Œ! ë°©ì¥ì˜ ìŠ¹ì¸ì„ ê¸°ë‹¤ë¦¬ì„¸ìš”.';
            announce('ì°¸ê°€ ìš”ì²­ì„ ë³´ëƒˆìŠµë‹ˆë‹¤. ë°©ì¥ì˜ ìŠ¹ì¸ì„ ê¸°ë‹¤ë¦¬ì„¸ìš”.');
            
        } catch (error) {
            console.error("ì°¸ê°€ ìš”ì²­ ì‹¤íŒ¨:", error);
            status.textContent = 'ìš”ì²­ ì‹¤íŒ¨';
            btn.disabled = false;
        }
    }

    // ==================== ë°©ì¥: ì°¸ê°€ ìš”ì²­ ìŠ¹ì¸ ====================
    async function approveJoinRequest(spectatorId, spectatorName) {
        if (myPlayerId !== 'player1' || !currentRoom) return;
        
        try {
            // ë¹ˆ í”Œë ˆì´ì–´ ìŠ¬ë¡¯ ì°¾ê¸°
            let nextPlayerNum = 1;
            while (players[`player${nextPlayerNum}`]) {
                nextPlayerNum++;
            }
            
            if (nextPlayerNum > maxPlayers) {
                alert('ë” ì´ìƒ í”Œë ˆì´ì–´ë¥¼ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            const newPlayerId = `player${nextPlayerNum}`;
            
            // í”Œë ˆì´ì–´ë¡œ ì¶”ê°€
            await update(ref(db, `rooms/${currentRoom}/players`), {
                [newPlayerId]: {
                    name: spectatorName,
                    connected: true,
                    finished: false,
                    rank: 0,
                    promotedFrom: spectatorId  // ì–´ë–¤ ê´€ì „ìê°€ ìŠ¹ê²©ëëŠ”ì§€ í‘œì‹œ
                }
            });
            
            // ê´€ì „ì ëª©ë¡ì—ì„œ ì œê±°
            await remove(ref(db, `rooms/${currentRoom}/spectators/${spectatorId}`));
            
            // ì°¸ê°€ ìš”ì²­ ëª©ë¡ì—ì„œ ì œê±°
            await remove(ref(db, `rooms/${currentRoom}/joinRequests/${spectatorId}`));
            
            announce(`${spectatorName}ë‹˜ì´ í”Œë ˆì´ì–´ë¡œ ì°¸ê°€í–ˆìŠµë‹ˆë‹¤.`);
            logMessage(`${spectatorName} í”Œë ˆì´ì–´ ì°¸ê°€`);
            
            // ì¸ì›ì´ ë‹¤ ì°¼ìœ¼ë©´ ê²Œì„ ì‹œì‘
            const updatedSnapshot = await get(ref(db, `rooms/${currentRoom}/players`));
            const currentPlayerCount = Object.keys(updatedSnapshot.val() || {}).length;
            
            if (currentPlayerCount >= maxPlayers) {
                // ê²Œì„ ì‹œì‘ - ì¹´ë“œ ë¶„ë°° ë° ì„  ì •í•˜ê¸°
                const { hands, firstPlayer } = distributeCardsWithFirst(maxPlayers);
                await update(ref(db, `rooms/${currentRoom}`), {
                    status: 'playing',
                    gameState: {
                        hands: hands,
                        currentTurn: firstPlayer,
                        lastMove: null,
                        lastMoveBy: null,
                        passCount: 0,
                        finishedOrder: []
                    }
                });
                announce('ì¸ì›ì´ ëª¨ë‘ ì°¼ìŠµë‹ˆë‹¤! ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.');
            }
            
        } catch (error) {
            console.error("ìŠ¹ì¸ ì‹¤íŒ¨:", error);
            alert('ìŠ¹ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
    }

    // ==================== ë°©ì¥: ì°¸ê°€ ìš”ì²­ ê±°ì ˆ ====================
    async function rejectJoinRequest(spectatorId) {
        if (myPlayerId !== 'player1' || !currentRoom) return;
        
        try {
            await remove(ref(db, `rooms/${currentRoom}/joinRequests/${spectatorId}`));
        } catch (error) {
            console.error("ê±°ì ˆ ì‹¤íŒ¨:", error);
        }
    }

    // ==================== ë°©ì¥: ê´€ì „ì ì§ì ‘ ì´ˆëŒ€ ====================
    async function inviteSpectator(spectatorId, spectatorName) {
        // approveJoinRequestì™€ ë™ì¼í•œ ë¡œì§
        await approveJoinRequest(spectatorId, spectatorName);
    }

    async function playAgain() {
        document.getElementById('result-modal').style.display = 'none';
        
        if (myPlayerId === 'player1') {
            // í”Œë ˆì´ì–´ ìƒíƒœ ë¦¬ì…‹
            const playerUpdates = {};
            Object.keys(players).forEach(id => {
                playerUpdates[`players/${id}/finished`] = false;
                playerUpdates[`players/${id}/rank`] = 0;
            });
            
            // ì¹´ë“œ ë¶„ë°° ë° ì„  ì •í•˜ê¸°
            const playerCount = Object.keys(players).length;
            const { hands, firstPlayer } = distributeCardsWithFirst(playerCount);
            
            await update(ref(db, `rooms/${currentRoom}`), {
                status: 'playing',
                ...playerUpdates,
                gameState: {
                    hands: hands,
                    currentTurn: firstPlayer,
                    lastMove: null,
                    lastMoveBy: null,
                    passCount: 0,
                    finishedOrder: []
                }
            });
        }
    }

    function logMessage(msg) {
        const logBox = document.getElementById('log');
        const p = document.createElement('p');
        p.textContent = msg;
        logBox.insertBefore(p, logBox.firstChild);
    }

    // ì „ì—­ í‚¤ë³´ë“œ (ALT ì¡°í•© - ìŠ¤í¬ë¦° ë¦¬ë” ì¶©ëŒ ë°©ì§€)
    document.addEventListener('keydown', (e) => {
        if (document.getElementById('lobby').style.display !== 'none') return;
        if (document.getElementById('result-modal').style.display === 'flex') return;
        
        // Escape: ì±„íŒ… ì…ë ¥ì°½ì—ì„œ ë‚˜ê°€ê¸°
        if (e.key === 'Escape') {
            const chatInput = document.getElementById('chat-input');
            if (document.activeElement === chatInput) {
                e.preventDefault();
                chatInput.blur();
                announce('ì±„íŒ… ëª¨ë“œ ì¢…ë£Œ');
                // ì²« ë²ˆì§¸ ì¹´ë“œë¡œ í¬ì»¤ìŠ¤ ì´ë™
                const firstCard = document.querySelector('.card');
                if (firstCard) firstCard.focus();
                return;
            }
        }
        
        // ALT í‚¤ ì¡°í•©ë§Œ ì²˜ë¦¬
        if (!e.altKey) return;
        
        switch (e.key) {
            case 'p': case 'P': 
                e.preventDefault();
                playMove(); 
                break;
            case 'x': case 'X': 
                e.preventDefault();
                passTurn(); 
                break;
            case 'c': case 'C': 
                e.preventDefault();
                clearSelection(); 
                break;
            case 's': case 'S': 
                e.preventDefault();
                announceStatus(); 
                break;
            case 't': case 'T':
                e.preventDefault();
                focusChatInput();
                break;
            case 'l': case 'L':
                e.preventDefault();
                readRecentChat();
                break;
            case 'q': case 'Q':
                e.preventDefault();
                toggleSound();
                break;
            case 'r': case 'R':
                e.preventDefault();
                doReturn();
                break;
            case 'm': case 'M':
                e.preventDefault();
                autoMine();
                break;
        }
    });
    
    // ì±„íŒ… ì…ë ¥ì°½ í¬ì»¤ìŠ¤
    function focusChatInput() {
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.focus();
            announce('ì±„íŒ… ëª¨ë“œ. ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”. Escapeë¡œ ë‚˜ê°€ê¸°.');
        }
    }
    
    // ìµœê·¼ ì±„íŒ… ì½ê¸°
    function readRecentChat() {
        const messages = document.querySelectorAll('.chat-list li');
        if (messages.length === 0) {
            announce('ì±„íŒ… ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        // ë§ˆì§€ë§‰ ë©”ì‹œì§€ë§Œ ì½ê¸°
        const lastMsg = messages[messages.length - 1];
        announce(lastMsg.textContent.trim());
    }

    // ==================== AI ëŒ€ì „ ëª¨ë“œ (Firebase ì—°ë™) ====================
    const aiNames = ['AI ì² ìˆ˜', 'AI ì˜í¬', 'AI ë¯¼ìˆ˜'];
    
    // ë¹ˆ ìë¦¬ì— AI ì¶”ê°€
    async function addAIPlayer() {
        if (!currentRoom || myPlayerId !== 'player1') {
            alert('ë°©ì¥ë§Œ AIë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            return;
        }
        
        try {
            const snapshot = await get(ref(db, `rooms/${currentRoom}`));
            if (!snapshot.exists()) return;
            
            const roomData = snapshot.val();
            const currentPlayers = Object.keys(roomData.players || {});
            const currentCount = currentPlayers.length;
            
            if (currentCount >= roomData.maxPlayers) {
                alert('ì´ë¯¸ ëª¨ë“  ìë¦¬ê°€ ì°¼ìŠµë‹ˆë‹¤.');
                return;
            }
            
            // ì´ë¯¸ ì¶”ê°€ëœ AI ìˆ˜ í™•ì¸
            const existingAIs = Object.values(roomData.players || {}).filter(p => p.isAI).length;
            if (existingAIs >= 3) {
                alert('AIëŠ” ìµœëŒ€ 3ëª…ê¹Œì§€ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }
            
            // ë‹¤ìŒ í”Œë ˆì´ì–´ ë²ˆí˜¸ ì°¾ê¸°
            let nextPlayerNum = 2;
            while (roomData.players?.[`player${nextPlayerNum}`]) {
                nextPlayerNum++;
            }
            
            const aiId = `player${nextPlayerNum}`;
            const aiName = aiNames[existingAIs];  // 0ë²ˆì§¸, 1ë²ˆì§¸, 2ë²ˆì§¸ ì´ë¦„ ìˆœì„œëŒ€ë¡œ
            
            // AI í”Œë ˆì´ì–´ ì¶”ê°€
            await update(ref(db, `rooms/${currentRoom}/players`), {
                [aiId]: {
                    name: aiName,
                    connected: true,
                    finished: false,
                    rank: 0,
                    isAI: true
                }
            });
            
            // isAIGame í”Œë˜ê·¸ ì„¤ì •
            await update(ref(db, `rooms/${currentRoom}`), {
                isAIGame: true
            });
            
            announce(`${aiName}ì´(ê°€) ì°¸ê°€í–ˆìŠµë‹ˆë‹¤.`);
            
            // ì¸ì› ë‹¤ ì°¼ëŠ”ì§€ í™•ì¸
            const updatedSnapshot = await get(ref(db, `rooms/${currentRoom}/players`));
            const updatedCount = Object.keys(updatedSnapshot.val() || {}).length;
            
            if (updatedCount >= roomData.maxPlayers) {
                // ê²Œì„ ì‹œì‘
                const { hands, firstPlayer } = distributeCardsWithFirst(roomData.maxPlayers);
                await update(ref(db, `rooms/${currentRoom}`), {
                    status: 'playing',
                    gameState: {
                        hands: hands,
                        currentTurn: firstPlayer,
                        lastMove: null,
                        lastMoveBy: null,
                        passCount: 0,
                        finishedOrder: []
                    }
                });
            }
            
        } catch (error) {
            console.error("AI ì¶”ê°€ ì‹¤íŒ¨:", error);
            alert("AI ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        }
    }
    
    async function startAIGame() {
        if (!isFirebaseReady) {
            alert("Firebaseê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
            return;
        }
        
        const aiCount = parseInt(document.getElementById('ai-player-count').value);
        myName = document.getElementById('player-name').value.trim() || 'í”Œë ˆì´ì–´';
        maxPlayers = aiCount + 1;  // AI + ë‚˜
        isAIGame = true;
        
        const roomCode = generateRoomCode();
        currentRoom = roomCode;
        myPlayerId = 'player1';
        
        // í”Œë ˆì´ì–´ ëª©ë¡ ìƒì„± (ë‚˜ + AIë“¤)
        const playersData = {
            player1: { name: myName, connected: true, finished: false, rank: 0, isAI: false }
        };
        
        for (let i = 0; i < aiCount; i++) {
            playersData[`player${i + 2}`] = {
                name: aiNames[i],
                connected: true,
                finished: false,
                rank: 0,
                isAI: true
            };
        }
        
        // ì¹´ë“œ ë¶„ë°° ë° ì„  ì •í•˜ê¸°
        const { hands, firstPlayer } = distributeCardsWithFirst(maxPlayers);
        
        try {
            // Firebaseì— ë°© ìƒì„± + ë°”ë¡œ ê²Œì„ ì‹œì‘
            await set(ref(db, `rooms/${roomCode}`), {
                host: myName,
                maxPlayers: maxPlayers,
                status: 'playing',
                isAIGame: true,
                players: playersData,
                spectators: {},
                gameState: {
                    hands: hands,
                    currentTurn: firstPlayer,
                    lastMove: null,
                    lastMoveBy: null,
                    passCount: 0,
                    finishedOrder: []
                }
            });
            
            onDisconnect(ref(db, `rooms/${roomCode}`)).remove();
            
            document.getElementById('lobby').style.display = 'none';
            playSound('gamestart');
            announce(`AI ëŒ€ì „ ì‹œì‘! ${aiCount}ëª…ì˜ AIì™€ ëŒ€ì „í•©ë‹ˆë‹¤. ${players[firstPlayer]?.name || firstPlayer}ì˜ ì„ ì…ë‹ˆë‹¤.`);
            
            watchRoom(roomCode);
            
        } catch (error) {
            console.error("AI ê²Œì„ ìƒì„± ì‹¤íŒ¨:", error);
            alert("AI ê²Œì„ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
            isAIGame = false;
        }
    }
    
    // AI í„´ ì²˜ë¦¬
    function processAITurn(data) {
        if (!isAIGame || aiThinking) return;
        if (data.status !== 'playing') return;
        
        const gs = data.gameState;
        const currentPlayer = gs.currentTurn;
        const playerInfo = data.players[currentPlayer];
        
        // AI í”Œë ˆì´ì–´ì¸ì§€ í™•ì¸
        if (!playerInfo?.isAI) return;
        
        // AIê°€ ì´ë¯¸ ì™„ì£¼í–ˆëŠ”ì§€ í™•ì¸
        if (playerInfo.finished) return;
        
        // ë§ˆì¸ ìƒíƒœì¼ ë•Œ ì²˜ë¦¬
        if (gs.lastMove?.isMine) {
            const mineBy = gs.lastMove.mineBy;
            const mineVal = gs.lastMove.val;
            const aiHand = gs.hands[currentPlayer];
            
            // ë§ˆì¸ í•œ AIì—ê²Œ í„´ì´ ëŒì•„ì™”ìœ¼ë©´: ë¦¬í„´ ëŒ€ê¸° í›„ ë°”ë‹¥ ë¹„ìš°ê³  ì§„í–‰
            if (mineBy === currentPlayer) {
                aiThinking = true;
                // ë¦¬í„´ ëŒ€ê¸° ì‹œê°„ í›„ ë§ˆì¸ ì„±ê³µ
                setTimeout(async () => {
                    await update(ref(db, `rooms/${currentRoom}/gameState`), {
                        lastMove: null,
                        lastMoveBy: null
                    });
                    logMessage(`${playerInfo.name}: ë§ˆì¸ ì„±ê³µ`);
                    
                    // ë§ˆì¸ ì„±ê³µ í›„ ë‹¤ìŒ ì¹´ë“œ ë‚´ê¸°
                    setTimeout(async () => {
                        aiThinking = false;
                        const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                        if (snapshot.exists()) {
                            processAITurn(snapshot.val());
                        }
                    }, AI_TURN_DELAY);
                }, 1000);
                return;
            }
            
            // ë‹¤ë¥¸ AIê°€ ë¦¬í„´í•  ìˆ˜ ìˆìœ¼ë©´ ë¦¬í„´
            const hasReturnCard = aiHand?.some(card => getCardValue(card) === mineVal);
            if (hasReturnCard) {
                aiThinking = true;
                // 5~10ì´ˆ ëŒ€ê¸° í›„ ë¦¬í„´ (ì‚¬ìš©ìì—ê²Œ ë¦¬í„´ ê¸°íšŒ ì£¼ê¸°)
                const delay = 2000;
                setTimeout(async () => {
                    const returnCardIndex = aiHand.findIndex(card => getCardValue(card) === mineVal);
                    const newHand = aiHand.filter((_, i) => i !== returnCardIndex);
                    
                    // ë¦¬í„´ í›„ ë°”ë‹¥ ë¹„ìš°ê¸° (ìƒˆ ì¹´ë“œ ë‚¼ ìˆ˜ ìˆë„ë¡)
                    await update(ref(db, `rooms/${currentRoom}`), {
                        [`gameState/hands/${currentPlayer}`]: newHand,
                        'gameState/lastMove': null,  // ë°”ë‹¥ ë¹„ì›€
                        'gameState/lastMoveBy': currentPlayer,
                        'gameState/passCount': 0,
                        'gameState/currentTurn': currentPlayer  // ë¦¬í„´ì€ í„´ ìœ ì§€
                    });
                    
                    logMessage(`${playerInfo.name}: ${mineVal}ë¦¬í„´`);
                    
                    // ë¦¬í„´ í›„ ë‹¤ìŒ ì¹´ë“œ ë‚´ê¸° (5ì´ˆ ëŒ€ê¸°)
                    setTimeout(async () => {
                        aiThinking = false;
                        // Firebaseì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì™€ì„œ ë‹¤ìŒ ì¹´ë“œ ë‚´ê¸°
                        const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                        if (snapshot.exists()) {
                            processAITurn(snapshot.val());
                        }
                    }, AI_TURN_DELAY);
                }, delay);
                return;
            } else {
                // ë¦¬í„´ ëª»í•˜ë©´ íŒ¨ìŠ¤ (5~10ì´ˆ ëŒ€ê¸° í›„ - ì‚¬ìš©ì ë¦¬í„´ ê¸°íšŒ)
                aiThinking = true;
                setTimeout(async () => {
                    await aiPass(currentPlayer, data);
                    // ë”œë ˆì´ í›„ ë‹¤ìŒ AI í„´ ì²´í¬
                    setTimeout(async () => {
                        aiThinking = false;
                        const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                        if (snapshot.exists()) {
                            processAITurn(snapshot.val());
                        }
                    }, AI_TURN_DELAY);
                }, 2000);
                return;
            }
        }
        
        aiThinking = true;
        
        // ë°”ë‹¥ì´ ì‹±ê¸€ì´ê³  AIê°€ ë§ˆì¸ ê°€ëŠ¥í•˜ë©´ ì‚¬ìš©ìì—ê²Œ ë§ˆì¸ ê¸°íšŒë¥¼ ì£¼ê¸° ìœ„í•´ ëŒ€ê¸°
        let delay = AI_TURN_DELAY + Math.random() * AI_TURN_RANDOM;
        
        // ì‚¬ìš©ìë„ ë§ˆì¸ ê°€ëŠ¥í•œ ìƒí™©ì¸ì§€ í™•ì¸
        if (gs.lastMove?.type === 'SINGLE' && !gs.lastMove?.isMine) {
            const targetVal = gs.lastMove.val;
            const userHand = gs.hands[myPlayerId] || [];
            const userCanMine = userHand.filter(c => getCardValue(c) === targetVal).length >= 2;
            
            if (userCanMine) {
                // ì‚¬ìš©ìë„ ë§ˆì¸ ê°€ëŠ¥í•˜ë©´ 7ì´ˆ ëŒ€ê¸°
                delay = 7000;
            }
        }
        
        setTimeout(async () => {
            try {
                // ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const freshSnapshot = await get(ref(db, `rooms/${currentRoom}`));
                if (!freshSnapshot.exists()) {
                    aiThinking = false;
                    return;
                }
                const freshData = freshSnapshot.val();
                const freshGs = freshData.gameState;
                
                // ê²Œì„ ì¢…ë£Œ í™•ì¸
                if (freshData.status !== 'playing') {
                    aiThinking = false;
                    return;
                }
                
                // í˜„ì¬ í„´ ë‹¤ì‹œ í™•ì¸
                if (freshGs.currentTurn !== currentPlayer) {
                    aiThinking = false;
                    processAITurn(freshData);
                    return;
                }
                
                const aiHand = freshGs.hands[currentPlayer];
                if (!aiHand || aiHand.length === 0) {
                    aiThinking = false;
                    // ì™„ì£¼í•œ ê²½ìš° ë‹¤ìŒ í„´ìœ¼ë¡œ
                    const nextTurn = getNextTurnFrom(currentPlayer, freshData);
                    await update(ref(db, `rooms/${currentRoom}/gameState`), {
                        currentTurn: nextTurn
                    });
                    setTimeout(() => processAITurn(freshData), AI_TURN_DELAY);
                    return;
                }
                
                // íŒ¨ìŠ¤í• ì§€ ê²°ì •
                if (shouldPass(aiHand, freshGs.lastMove, freshData)) {
                    await aiPass(currentPlayer, freshData);
                    aiThinking = false;
                    // ë‹¤ìŒ AI í„´ ì²´í¬
                    setTimeout(async () => {
                        const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                        if (snapshot.exists()) {
                            processAITurn(snapshot.val());
                        }
                    }, AI_TURN_DELAY + Math.random() * AI_TURN_RANDOM);
                    return;
                }
                
                // ìµœì ì˜ ìˆ˜ ì°¾ê¸°
                const move = findBestMove(aiHand, freshGs.lastMove, freshData);
                
                if (move) {
                    await aiPlayMove(currentPlayer, aiHand, move, freshData);
                } else {
                    await aiPass(currentPlayer, freshData);
                }
                
                aiThinking = false;
                
                // ë‹¤ìŒ AI í„´ ì²´í¬
                setTimeout(async () => {
                    const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                    if (snapshot.exists()) {
                        processAITurn(snapshot.val());
                    }
                }, AI_TURN_DELAY + Math.random() * AI_TURN_RANDOM);
            } catch (error) {
                console.error("AI í„´ ì²˜ë¦¬ ì‹¤íŒ¨:", error);
                aiThinking = false;
                // ì—ëŸ¬ ë°œìƒ ì‹œ ì¬ì‹œë„
                setTimeout(async () => {
                    const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                    if (snapshot.exists()) {
                        processAITurn(snapshot.val());
                    }
                }, AI_TURN_DELAY);
            }
        }, delay);
    }
    
    // AIìš© ì „ëµì  ìµœì  ì¡°í•© ì°¾ê¸°
    function findBestMove(hand, lastMove, roomData) {
        const validMoves = getAllValidMoves(hand, lastMove);
        
        if (validMoves.length === 0) return null;
        
        // ê° ìˆ˜ì— ì ìˆ˜ ë¶€ì—¬
        const scoredMoves = validMoves.map(moveData => {
            const score = evaluateMove(moveData, hand, lastMove, roomData);
            return { ...moveData, score };
        });
        
        // ì ìˆ˜ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
        scoredMoves.sort((a, b) => b.score - a.score);
        
        // ìµœê³  ì ìˆ˜ ìˆ˜ ì„ íƒ (ë™ì ì´ë©´ ëœë¤)
        const topScore = scoredMoves[0].score;
        const topMoves = scoredMoves.filter(m => m.score === topScore);
        
        return topMoves[Math.floor(Math.random() * topMoves.length)];
    }
    
    // ëª¨ë“  ìœ íš¨í•œ ìˆ˜ ì°¾ê¸°
    function getAllValidMoves(hand, lastMove) {
        const validMoves = [];
        const handLength = hand.length;
        
        // ì‹±ê¸€ (1ì¥)
        for (let i = 0; i < handLength; i++) {
            const cards = [hand[i]];
            const move = getMoveInfo(cards);
            if (move) {
                // ì¼ë°˜ ì‹±ê¸€ ë˜ëŠ” ë¦¬í„´ (ë§ˆì¸ í˜ì–´ì— ê°™ì€ ê°’ ì‹±ê¸€)
                if (canBeatMove(move, lastMove)) {
                    validMoves.push({ indices: [i], move, cards });
                } else if (lastMove && lastMove.isMine && lastMove.type === 'PAIR' && move.val === lastMove.val) {
                    // ë¦¬í„´
                    move.isReturn = true;
                    validMoves.push({ indices: [i], move, cards });
                }
            }
        }
        
        // í˜ì–´ (2ì¥)
        for (let i = 0; i < handLength; i++) {
            for (let j = i + 1; j < handLength; j++) {
                const cards = [hand[i], hand[j]];
                const move = getMoveInfo(cards);
                if (move && move.type === 'PAIR') {
                    // ì¼ë°˜ í˜ì–´ ë˜ëŠ” ë§ˆì¸ (ì‹±ê¸€ì— ê°™ì€ ê°’ í˜ì–´)
                    if (canBeatMove(move, lastMove)) {
                        validMoves.push({ indices: [i, j], move, cards });
                    } else if (lastMove && lastMove.type === 'SINGLE' && move.val === lastMove.val) {
                        // ë§ˆì¸
                        move.isMine = true;
                        validMoves.push({ indices: [i, j], move, cards });
                    }
                }
            }
        }
        
        // BOMB (3ì¥)
        for (let i = 0; i < handLength; i++) {
            for (let j = i + 1; j < handLength; j++) {
                for (let k = j + 1; k < handLength; k++) {
                    const cards = [hand[i], hand[j], hand[k]];
                    const move = getMoveInfo(cards);
                    if (move && move.type === 'BOMB' && canBeatMove(move, lastMove)) {
                        validMoves.push({ indices: [i, j, k], move, cards });
                    }
                }
            }
        }
        
        // BOMB_TWO (4ì¥)
        for (let i = 0; i < handLength; i++) {
            for (let j = i + 1; j < handLength; j++) {
                for (let k = j + 1; k < handLength; k++) {
                    for (let l = k + 1; l < handLength; l++) {
                        const cards = [hand[i], hand[j], hand[k], hand[l]];
                        const move = getMoveInfo(cards);
                        if (move && move.type === 'BOMB_TWO' && canBeatMove(move, lastMove)) {
                            validMoves.push({ indices: [i, j, k, l], move, cards });
                        }
                    }
                }
            }
        }
        
        // ìŠ¤íŠ¸ë ˆì´íŠ¸ (3ì¥ ì´ìƒ ì—°ì†)
        const sortedHand = hand.map((c, i) => ({ card: c, value: getCardValue(c), idx: i }))
                               .sort((a, b) => a.value - b.value);
        
        for (let len = 3; len <= Math.min(8, handLength); len++) {
            for (let start = 0; start <= sortedHand.length - len; start++) {
                const subset = sortedHand.slice(start, start + len);
                const cards = subset.map(s => s.card);
                const indices = subset.map(s => s.idx);
                const move = getMoveInfo(cards);
                
                if (move && move.type === 'STRAIGHT' && canBeatMove(move, lastMove)) {
                    validMoves.push({ indices, move, cards });
                }
            }
        }
        
        // í˜ì–´ ìŠ¤íŠ¸ë ˆì´íŠ¸ (ì—°ì†ëœ ìˆ«ì 2ì¥ì”©)
        // ê°’ë³„ë¡œ ì¸ë±ìŠ¤ ê·¸ë£¹í•‘
        const valueGroups = {};
        for (let i = 0; i < handLength; i++) {
            const val = getCardValue(hand[i]);
            if (!valueGroups[val]) valueGroups[val] = [];
            valueGroups[val].push(i);
        }
        
        // ì—°ì†ëœ ê°’ë“¤ ì¤‘ 2ê°œ ì´ìƒ ìˆëŠ” ê²ƒë“¤ ì°¾ê¸°
        const pairableValues = Object.keys(valueGroups)
            .map(Number)
            .filter(v => valueGroups[v].length >= 2)
            .sort((a, b) => a - b);
        
        // í˜ì–´ ìŠ¤íŠ¸ë ˆì´íŠ¸ ì¡°í•© (2~4ê°œ ì—°ì† í˜ì–´ = 4~8ì¥)
        for (let pairLen = 3; pairLen <= 4; pairLen++) {
            for (let startIdx = 0; startIdx <= pairableValues.length - pairLen; startIdx++) {
                // ì—°ì†ì¸ì§€ í™•ì¸
                let isConsecutive = true;
                for (let i = 0; i < pairLen - 1; i++) {
                    if (pairableValues[startIdx + i] + 1 !== pairableValues[startIdx + i + 1]) {
                        isConsecutive = false;
                        break;
                    }
                }
                
                if (isConsecutive) {
                    const indices = [];
                    const cards = [];
                    for (let i = 0; i < pairLen; i++) {
                        const val = pairableValues[startIdx + i];
                        // ê° ê°’ì—ì„œ 2ì¥ì”© ì„ íƒ
                        indices.push(valueGroups[val][0], valueGroups[val][1]);
                        cards.push(hand[valueGroups[val][0]], hand[valueGroups[val][1]]);
                    }
                    
                    const move = getMoveInfo(cards);
                    if (move && move.type === 'PAIR_STRAIGHT' && canBeatMove(move, lastMove)) {
                        validMoves.push({ indices, move, cards });
                    }
                }
            }
        }
        
        return validMoves;
    }
    
    // ìˆ˜ í‰ê°€ (ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ)
    function evaluateMove(moveData, hand, lastMove, roomData) {
        const { move, cards, indices } = moveData;
        let score = 100;  // ê¸°ë³¸ ì ìˆ˜
        
        // 1. ë‚®ì€ ê°’ ì¹´ë“œ ì‚¬ìš© = ë†’ì€ ì ìˆ˜ (ë†’ì€ ì¹´ë“œ ë³´ì¡´)
        score += (16 - move.val) * 5;
        
        // 2. ì—¬ëŸ¬ ì¥ í•œë²ˆì— ë‚´ë©´ ì¢‹ìŒ (íŒ¨ ë¹¨ë¦¬ ì¤„ì´ê¸°)
        score += move.cnt * 8;
        
        // 3. í­íƒ„ì€ ì ìˆ˜ ë‚®ì¶¤ (ë‚˜ì¤‘ì— ì“°ë ¤ê³  ë³´ì¡´)
        if (move.type === 'BOMB') {
            score -= 30;
        }
        if (move.type === 'BOMB_TWO') {
            score -= 50;
        }
        
        // 4. ìŠ¤íŠ¸ë ˆì´íŠ¸ëŠ” ì¢‹ìŒ (ì—¬ëŸ¬ ì¥ ì²˜ë¦¬)
        if (move.type === 'STRAIGHT') {
            score += 15;
        }
        
        // 4-1. í˜ì–´ ìŠ¤íŠ¸ë ˆì´íŠ¸ë„ ì¢‹ìŒ
        if (move.type === 'PAIR_STRAIGHT') {
            score += 20;
        }
        
        // 4-2. ë§ˆì¸ì€ ë§¤ìš° ì¢‹ìŒ (ì„  ê°€ì ¸ì˜´)
        if (move.isMine) {
            score += 50;
        }
        
        // 4-3. ë¦¬í„´ë„ ì¢‹ìŒ (ì„  ê°€ì ¸ì˜´)
        if (move.isReturn) {
            score += 50;
        }
        
        // 5. ë°”ë‹¥ì´ ì—†ìœ¼ë©´ (ìƒˆ í„´) ë‚®ì€ ì‹±ê¸€ ìš°ì„ 
        if (!lastMove) {
            if (move.type === 'SINGLE' && move.val <= 5) {
                score += 20;
            }
        }
        
        // 6. ë°”ë‹¥ì„ ê²¨ìš° ì´ê¸°ëŠ” ê²Œ ì¢‹ìŒ (ì¹´ë“œ ë‚­ë¹„ ë°©ì§€)
        if (lastMove && move.type === lastMove.type) {
            const valueDiff = move.val - lastMove.val;
            if (valueDiff === 1) {
                score += 15;  // ë”± 1 ì°¨ì´ë¡œ ì´ê¸°ë©´ ë³´ë„ˆìŠ¤
            } else if (valueDiff > 3) {
                score -= 10;  // ë„ˆë¬´ ë†’ì€ ì¹´ë“œë¡œ ì´ê¸°ë©´ ê°ì 
            }
        }
        
        // 7. ë‚´ íŒ¨ê°€ ì ìœ¼ë©´ ê³µê²©ì ìœ¼ë¡œ
        if (hand.length <= 5) {
            score += 10;
            // íŒ¨ê°€ ì ì„ ë•ŒëŠ” í­íƒ„ ì‚¬ìš© OK
            if (move.type === 'BOMB') score += 20;
            if (move.type === 'BOMB_TWO') score += 30;
        }
        
        // 8. ìƒëŒ€ ì¤‘ íŒ¨ê°€ ì ì€ ì‚¬ëŒ ìˆìœ¼ë©´ í­íƒ„ ê³ ë ¤
        if (roomData) {
            const opponentHands = Object.entries(roomData.gameState.hands || {})
                .filter(([id]) => id !== roomData.gameState.currentTurn);
            
            const minOpponentCards = Math.min(...opponentHands.map(([_, h]) => h?.length || 99));
            
            if (minOpponentCards <= 3) {
                // ìƒëŒ€ê°€ ê³§ ì´ê¸¸ ê²ƒ ê°™ìœ¼ë©´ í­íƒ„ ì‚¬ìš©!
                if (move.type === 'BOMB') score += 40;
                if (move.type === 'BOMB_TWO') score += 60;
            }
        }
        
        return score;
    }
    
    // íŒ¨ìŠ¤í• ì§€ ê²°ì •
    function shouldPass(hand, lastMove, roomData) {
        // ë°”ë‹¥ì´ ì—†ìœ¼ë©´ ë¬´ì¡°ê±´ ë‚´ì•¼ í•¨
        if (!lastMove) return false;
        
        const validMoves = getAllValidMoves(hand, lastMove);
        
        // ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œê°€ ì—†ìœ¼ë©´ íŒ¨ìŠ¤
        if (validMoves.length === 0) return true;
        
        // í­íƒ„ë§Œ ìˆê³ , ë‚´ íŒ¨ê°€ ë§ìœ¼ë©´ íŒ¨ìŠ¤ (í­íƒ„ ë³´ì¡´)
        const nonBombMoves = validMoves.filter(m => m.move.type !== 'BOMB' && m.move.type !== 'BOMB_TWO');
        if (nonBombMoves.length === 0 && hand.length > 8) {
            return true;  // í­íƒ„ ì•„ê»´ë‘ê¸°
        }
        
        // ë†’ì€ ì¹´ë“œë§Œ ë‚¼ ìˆ˜ ìˆê³ , ë°”ë‹¥ì´ ë‚®ìœ¼ë©´ íŒ¨ìŠ¤ ê³ ë ¤
        const minValue = Math.min(...validMoves.map(m => m.move.val));
        if (minValue >= 13 && lastMove.val <= 8 && hand.length > 5) {
            // 50% í™•ë¥ ë¡œ íŒ¨ìŠ¤ (ë„ˆë¬´ ì˜ˆì¸¡ ê°€ëŠ¥í•˜ì§€ ì•Šê²Œ)
            return Math.random() < 0.5;
        }
        
        return false;
    }
    
    // canBeat í•¨ìˆ˜ì™€ ë™ì¼í•˜ì§€ë§Œ lastMoveë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë°›ìŒ
    function canBeatMove(newMove, lastMove) {
        if (!lastMove) return true;
        
        if (newMove.type === 'BOMB_TWO') {
            if (lastMove.type !== 'BOMB_TWO') return true;
            return newMove.val > lastMove.val;
        }
        
        if (newMove.type === 'BOMB') {
            if (lastMove.type === 'BOMB_TWO') return false;
            if (lastMove.type !== 'BOMB') return true;
            return newMove.val > lastMove.val;
        }
        
        if (newMove.type === lastMove.type && newMove.cnt === lastMove.cnt) {
            return newMove.val > lastMove.val;
        }
        
        return false;
    }
    
    // AI ì¹´ë“œ ë‚´ê¸°
    async function aiPlayMove(playerId, hand, moveData, roomData) {
        const { indices, move, cards } = moveData;
        const newHand = hand.filter((_, i) => !indices.includes(i));
        const playerName = roomData.players[playerId].name;
        
        // ë§ˆì¸ì´ë©´ mineBy ì„¤ì •
        if (move.isMine) {
            move.mineBy = playerId;
        }
        
        // ë¦¬í„´ë§Œ í„´ ìœ ì§€, ë§ˆì¸ì€ í„´ ë„˜ê¹€ (ë¦¬í„´ ê¸°íšŒ ì¤Œ)
        const keepTurn = move.isReturn === true;
        
        const updates = {
            [`gameState/hands/${playerId}`]: newHand,
            'gameState/lastMove': move,
            'gameState/lastMoveBy': playerId,
            'gameState/passCount': 0  // ì¹´ë“œ ë‚´ë©´ íŒ¨ìŠ¤ ì¹´ìš´íŠ¸ ë¦¬ì…‹
        };
        
        // 3ì¹´ë“œ ì•Œë¦¼ (3ì¥ ë‚¨ìœ¼ë©´)
        if (newHand.length === 3) {
            setTimeout(() => {
                showToast(`ğŸ“¢ ${playerName}: 3ì¹´ë“œ!`, 'warning');
                announce(`${playerName}: 3ì¹´ë“œ!`);
                logMessage(`${playerName}: 3ì¹´ë“œ!`);
                playSound('warning');
            }, 500);
        }
        
        // ì™„ì£¼ ì²´í¬ - ëˆ„êµ°ê°€ íŒ¨ë¥¼ ë‹¤ ë‚´ë©´ ë°”ë¡œ ê²Œì„ ì¢…ë£Œ
        if (newHand.length === 0) {
            const currentFinished = roomData.gameState.finishedOrder?.length || 0;
            const rank = currentFinished + 1;
            
            updates[`players/${playerId}/finished`] = true;
            updates[`players/${playerId}/rank`] = rank;
            updates['gameState/finishedOrder'] = [...(roomData.gameState.finishedOrder || []), playerId];
            updates['status'] = 'finished';  // ë°”ë¡œ ê²Œì„ ì¢…ë£Œ
        } else if (keepTurn) {
            // ë¦¬í„´: í„´ ìœ ì§€
            updates['gameState/currentTurn'] = playerId;
        } else {
            updates['gameState/currentTurn'] = getNextTurnFrom(playerId, roomData);
        }
        
        await update(ref(db, `rooms/${currentRoom}`), updates);
    }
    
    // AI íŒ¨ìŠ¤
    async function aiPass(playerId, roomData) {
        const playerName = roomData.players[playerId].name;
        const gs = roomData.gameState;
        const nextTurn = getNextTurnFrom(playerId, roomData);
        
        logMessage(`${playerName}: íŒ¨ìŠ¤`);
        
        // ë§ˆì¸ ìƒíƒœì—ì„œëŠ” ë‹¨ìˆœíˆ ë‹¤ìŒ í„´ìœ¼ë¡œ ë„˜ê¹€ (ë§ˆì¸í•œ ì‚¬ëŒì—ê²Œ ëŒì•„ê°€ë©´ ë§ˆì¸ ì„±ê³µ)
        if (gs.lastMove?.isMine) {
            await update(ref(db, `rooms/${currentRoom}/gameState`), {
                currentTurn: nextTurn,
                passedBy: playerId
            });
            return;
        }
        
        // í™œì„± í”Œë ˆì´ì–´ ìˆ˜ (ì™„ì£¼í•˜ì§€ ì•Šì€ í”Œë ˆì´ì–´)
        const activePlayers = Object.entries(roomData.players)
            .filter(([id, p]) => !p.finished)
            .length;
        
        const currentPassCount = (gs.passCount || 0) + 1;
        
        // ëª¨ë‘ íŒ¨ìŠ¤í–ˆìœ¼ë©´ (í™œì„± í”Œë ˆì´ì–´ - 1ëª… ëª¨ë‘ íŒ¨ìŠ¤) â†’ ì„ ì„ ì¡ìŒ
        if (currentPassCount >= activePlayers - 1 && gs.lastMoveBy) {
            const newTurnPlayer = gs.lastMoveBy;
            await update(ref(db, `rooms/${currentRoom}/gameState`), {
                currentTurn: newTurnPlayer,
                lastMove: null,
                lastMoveBy: null,
                passCount: 0,
                passedBy: playerId
            });
            logMessage(`${roomData.players[newTurnPlayer]?.name || newTurnPlayer}: ì„ ì„ ì¡ìŒ`);
            
            // ì„ ì„ ì¡ì€ í”Œë ˆì´ì–´ê°€ AIë©´ ë”œë ˆì´ í›„ í„´ ì²˜ë¦¬
            if (roomData.players[newTurnPlayer]?.isAI) {
                setTimeout(async () => {
                    aiThinking = false;
                    const snapshot = await get(ref(db, `rooms/${currentRoom}`));
                    if (snapshot.exists()) {
                        processAITurn(snapshot.val());
                    }
                }, AI_TURN_DELAY);
            }
        } else {
            // ì¼ë°˜ íŒ¨ìŠ¤
            await update(ref(db, `rooms/${currentRoom}/gameState`), {
                currentTurn: nextTurn,
                passCount: currentPassCount,
                passedBy: playerId
            });
        }
    }
    
    // ë‹¤ìŒ í„´ ê³„ì‚° (roomData ê¸°ë°˜)
    function getNextTurnFrom(currentPlayerId, roomData) {
        const playerIds = Object.keys(roomData.players).sort();
        const currentIndex = playerIds.indexOf(currentPlayerId);
        
        for (let i = 1; i <= playerIds.length; i++) {
            const nextIndex = (currentIndex + i) % playerIds.length;
            const nextId = playerIds[nextIndex];
            if (!roomData.players[nextId].finished) {
                return nextId;
            }
        }
        
        return playerIds[0];
    }
</script>
</body>

<!-- ê³ ëŒ€ë¹„ ëª¨ë“œ í† ê¸€ ë²„íŠ¼ -->
<button id="accessibility-toggle" onclick="toggleHighContrast()" aria-label="ê³ ëŒ€ë¹„ ëª¨ë“œ ì¼œê¸°">ğŸ‘ï¸ ê³ ëŒ€ë¹„</button>

</html>
